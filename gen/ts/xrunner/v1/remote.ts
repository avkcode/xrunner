// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.2
// source: xrunner/v1/remote.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../../google/protobuf/empty";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "xrunner.v1";

export interface RemoteVersionResponse {
  version: string;
  commit: string;
  buildTime: string;
}

export interface ReadFileRequest {
  path: string;
}

export interface ReadFileResponse {
  data: Uint8Array;
}

export interface WriteFileRequest {
  path: string;
  data: Uint8Array;
  mode: number;
}

export interface OpenPTYRequest {
  command: string;
  args: string[];
  cwd: string;
  env: { [key: string]: string };
  cols: number;
  rows: number;
}

export interface OpenPTYRequest_EnvEntry {
  key: string;
  value: string;
}

export interface OpenPTYResponse {
  sessionId: string;
}

export interface PTYStreamRequest {
  sessionId: string;
}

export interface PTYOutputChunk {
  timestamp: Date | undefined;
  data: Uint8Array;
}

export interface PTYWriteRequest {
  sessionId: string;
  data: Uint8Array;
}

export interface PTYResizeRequest {
  sessionId: string;
  cols: number;
  rows: number;
}

export interface PTYCloseRequest {
  sessionId: string;
}

export interface EnsureShellSessionRequest {
  /** Stable durable session name (e.g. "ops"). */
  name: string;
  /** Optional shell to start when creating a new session (defaults to "sh"). */
  shell: string;
  args: string[];
  /** Optional working dir/env used only on initial create. */
  cwd: string;
  env: { [key: string]: string };
  /** Initial size (best-effort). */
  cols: number;
  rows: number;
}

export interface EnsureShellSessionRequest_EnvEntry {
  key: string;
  value: string;
}

export interface EnsureShellSessionResponse {
  name: string;
  logSize: number;
}

export interface ShellStreamRequest {
  name: string;
  offset: number;
  follow: boolean;
  /** Max bytes per chunk (defaults to 64KiB). */
  maxChunkBytes: number;
  /** Poll interval while following (defaults to 50ms). */
  pollMs: number;
}

export interface ShellOutputChunk {
  timestamp: Date | undefined;
  offset: number;
  data: Uint8Array;
}

export interface ShellWriteRequest {
  name: string;
  data: Uint8Array;
}

export interface ShellResizeRequest {
  name: string;
  cols: number;
  rows: number;
}

export interface ShellCloseRequest {
  name: string;
  /** If true, kills the underlying durable session. */
  kill: boolean;
}

export interface ShellTailRequest {
  name: string;
  lines: number;
  /** Max bytes returned (defaults to 1MiB). */
  maxBytes: number;
}

export interface ShellTailResponse {
  name: string;
  data: Uint8Array;
  logSize: number;
}

export interface ShellRunRequest {
  name: string;
  command: string;
  /** Optional client-supplied command id (server generates one if empty). */
  commandId: string;
  /** Timeout in milliseconds (0 uses server default). */
  timeoutMs: number;
}

export interface ShellRunResponse {
  name: string;
  commandId: string;
  exitCode: number;
  beginOffset: number;
  endOffset: number;
  startedAt: Date | undefined;
  completedAt: Date | undefined;
}

export interface ShellClientHello {
  name: string;
  /** If non-zero, start streaming from this byte offset in the durable log. */
  afterOffset: number;
  /** Optional stable client identifier to enable server-side resume. */
  clientId: string;
  /** If true and after_offset==0, server resumes from last acknowledged offset for this client. */
  resumeFromLastAck: boolean;
  /** Output coalescing knobs. */
  maxChunkBytes: number;
  pollMs: number;
  compression: ShellClientHello_Compression;
}

export enum ShellClientHello_Compression {
  COMPRESSION_NONE = 0,
  COMPRESSION_ZSTD = 1,
  UNRECOGNIZED = -1,
}

export function shellClientHello_CompressionFromJSON(object: any): ShellClientHello_Compression {
  switch (object) {
    case 0:
    case "COMPRESSION_NONE":
      return ShellClientHello_Compression.COMPRESSION_NONE;
    case 1:
    case "COMPRESSION_ZSTD":
      return ShellClientHello_Compression.COMPRESSION_ZSTD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ShellClientHello_Compression.UNRECOGNIZED;
  }
}

export function shellClientHello_CompressionToJSON(object: ShellClientHello_Compression): string {
  switch (object) {
    case ShellClientHello_Compression.COMPRESSION_NONE:
      return "COMPRESSION_NONE";
    case ShellClientHello_Compression.COMPRESSION_ZSTD:
      return "COMPRESSION_ZSTD";
    case ShellClientHello_Compression.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ShellClientAck {
  name: string;
  clientId: string;
  ackOffset: number;
}

export interface ShellClientInput {
  name: string;
  data: Uint8Array;
}

export interface ShellClientResize {
  name: string;
  cols: number;
  rows: number;
}

export interface ShellClientRun {
  name: string;
  command: string;
  /** Optional client-supplied command id (server generates one if empty). */
  commandId: string;
  /** Timeout in milliseconds (0 uses server default). */
  timeoutMs: number;
}

export interface ShellClientClose {
  name: string;
  kill: boolean;
}

export interface ShellClientMsg {
  hello?: ShellClientHello | undefined;
  ack?: ShellClientAck | undefined;
  input?: ShellClientInput | undefined;
  resize?: ShellClientResize | undefined;
  run?: ShellClientRun | undefined;
  close?: ShellClientClose | undefined;
}

export interface ShellServerHello {
  name: string;
  startOffset: number;
  logSize: number;
  compression: ShellClientHello_Compression;
}

export interface ShellServerChunk {
  name: string;
  offset: number;
  data: Uint8Array;
  /** Uncompressed size of the chunk. If compression is NONE, this equals len(data). */
  uncompressedLen: number;
}

export interface ShellServerCommandEvent {
  name: string;
  record: ShellCommandRecord | undefined;
  phase: ShellServerCommandEvent_Phase;
}

export enum ShellServerCommandEvent_Phase {
  PHASE_UNSPECIFIED = 0,
  PHASE_STARTED = 1,
  PHASE_COMPLETED = 2,
  UNRECOGNIZED = -1,
}

export function shellServerCommandEvent_PhaseFromJSON(object: any): ShellServerCommandEvent_Phase {
  switch (object) {
    case 0:
    case "PHASE_UNSPECIFIED":
      return ShellServerCommandEvent_Phase.PHASE_UNSPECIFIED;
    case 1:
    case "PHASE_STARTED":
      return ShellServerCommandEvent_Phase.PHASE_STARTED;
    case 2:
    case "PHASE_COMPLETED":
      return ShellServerCommandEvent_Phase.PHASE_COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ShellServerCommandEvent_Phase.UNRECOGNIZED;
  }
}

export function shellServerCommandEvent_PhaseToJSON(object: ShellServerCommandEvent_Phase): string {
  switch (object) {
    case ShellServerCommandEvent_Phase.PHASE_UNSPECIFIED:
      return "PHASE_UNSPECIFIED";
    case ShellServerCommandEvent_Phase.PHASE_STARTED:
      return "PHASE_STARTED";
    case ShellServerCommandEvent_Phase.PHASE_COMPLETED:
      return "PHASE_COMPLETED";
    case ShellServerCommandEvent_Phase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ShellServerMsg {
  hello?: ShellServerHello | undefined;
  chunk?: ShellServerChunk | undefined;
  command?: ShellServerCommandEvent | undefined;
}

export interface ShellCommandRecord {
  name: string;
  commandId: string;
  command: string;
  exitCode: number;
  beginOffset: number;
  endOffset: number;
  startedAt: Date | undefined;
  completedAt: Date | undefined;
  outputBytes: number;
  artifactIds: string[];
}

export interface ShellArtifact {
  id: string;
  name: string;
  commandId: string;
  /** e.g. "go_test_failure" */
  type: string;
  title: string;
  /** structured payload for clients */
  dataJson: Uint8Array;
  createdAt: Date | undefined;
}

export interface ListShellArtifactsRequest {
  name: string;
  /** optional filter */
  commandId: string;
  /** default 50 */
  limit: number;
}

export interface ListShellArtifactsResponse {
  artifacts: ShellArtifact[];
}

export interface ListShellCommandsRequest {
  name: string;
  /** default 50 */
  limit: number;
}

export interface ListShellCommandsResponse {
  commands: ShellCommandRecord[];
}

export interface ShellSearchRequest {
  name: string;
  query: Uint8Array;
  /** Optional limits. */
  startOffset: number;
  /** 0 means EOF */
  endOffset: number;
  /** Optional filters. */
  commandId: string;
  startTime: Date | undefined;
  endTime:
    | Date
    | undefined;
  /** default 50 */
  maxMatches: number;
  /** default 80 */
  contextBytes: number;
}

export interface ShellSearchMatch {
  commandId: string;
  offset: number;
  snippet: Uint8Array;
}

export interface ShellSearchResponse {
  matches: ShellSearchMatch[];
  logSize: number;
}

function createBaseRemoteVersionResponse(): RemoteVersionResponse {
  return { version: "", commit: "", buildTime: "" };
}

export const RemoteVersionResponse: MessageFns<RemoteVersionResponse> = {
  encode(message: RemoteVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.commit !== "") {
      writer.uint32(18).string(message.commit);
    }
    if (message.buildTime !== "") {
      writer.uint32(26).string(message.buildTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commit = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buildTime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteVersionResponse {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      commit: isSet(object.commit) ? globalThis.String(object.commit) : "",
      buildTime: isSet(object.buildTime) ? globalThis.String(object.buildTime) : "",
    };
  },

  toJSON(message: RemoteVersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.commit !== "") {
      obj.commit = message.commit;
    }
    if (message.buildTime !== "") {
      obj.buildTime = message.buildTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoteVersionResponse>, I>>(base?: I): RemoteVersionResponse {
    return RemoteVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoteVersionResponse>, I>>(object: I): RemoteVersionResponse {
    const message = createBaseRemoteVersionResponse();
    message.version = object.version ?? "";
    message.commit = object.commit ?? "";
    message.buildTime = object.buildTime ?? "";
    return message;
  },
};

function createBaseReadFileRequest(): ReadFileRequest {
  return { path: "" };
}

export const ReadFileRequest: MessageFns<ReadFileRequest> = {
  encode(message: ReadFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFileRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ReadFileRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFileRequest>, I>>(base?: I): ReadFileRequest {
    return ReadFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFileRequest>, I>>(object: I): ReadFileRequest {
    const message = createBaseReadFileRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseReadFileResponse(): ReadFileResponse {
  return { data: new Uint8Array(0) };
}

export const ReadFileResponse: MessageFns<ReadFileResponse> = {
  encode(message: ReadFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFileResponse {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: ReadFileResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFileResponse>, I>>(base?: I): ReadFileResponse {
    return ReadFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFileResponse>, I>>(object: I): ReadFileResponse {
    const message = createBaseReadFileResponse();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWriteFileRequest(): WriteFileRequest {
  return { path: "", data: new Uint8Array(0), mode: 0 };
}

export const WriteFileRequest: MessageFns<WriteFileRequest> = {
  encode(message: WriteFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.mode !== 0) {
      writer.uint32(24).uint32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteFileRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
    };
  },

  toJSON(message: WriteFileRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFileRequest>, I>>(base?: I): WriteFileRequest {
    return WriteFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFileRequest>, I>>(object: I): WriteFileRequest {
    const message = createBaseWriteFileRequest();
    message.path = object.path ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseOpenPTYRequest(): OpenPTYRequest {
  return { command: "", args: [], cwd: "", env: {}, cols: 0, rows: 0 };
}

export const OpenPTYRequest: MessageFns<OpenPTYRequest> = {
  encode(message: OpenPTYRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    for (const v of message.args) {
      writer.uint32(18).string(v!);
    }
    if (message.cwd !== "") {
      writer.uint32(26).string(message.cwd);
    }
    Object.entries(message.env).forEach(([key, value]) => {
      OpenPTYRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.cols !== 0) {
      writer.uint32(40).uint32(message.cols);
    }
    if (message.rows !== 0) {
      writer.uint32(48).uint32(message.rows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenPTYRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenPTYRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = OpenPTYRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.env[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.cols = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rows = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenPTYRequest {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : "",
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      cols: isSet(object.cols) ? globalThis.Number(object.cols) : 0,
      rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
    };
  },

  toJSON(message: OpenPTYRequest): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.cwd !== "") {
      obj.cwd = message.cwd;
    }
    if (message.env) {
      const entries = Object.entries(message.env);
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.cols !== 0) {
      obj.cols = Math.round(message.cols);
    }
    if (message.rows !== 0) {
      obj.rows = Math.round(message.rows);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenPTYRequest>, I>>(base?: I): OpenPTYRequest {
    return OpenPTYRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenPTYRequest>, I>>(object: I): OpenPTYRequest {
    const message = createBaseOpenPTYRequest();
    message.command = object.command ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.cwd = object.cwd ?? "";
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.cols = object.cols ?? 0;
    message.rows = object.rows ?? 0;
    return message;
  },
};

function createBaseOpenPTYRequest_EnvEntry(): OpenPTYRequest_EnvEntry {
  return { key: "", value: "" };
}

export const OpenPTYRequest_EnvEntry: MessageFns<OpenPTYRequest_EnvEntry> = {
  encode(message: OpenPTYRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenPTYRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenPTYRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenPTYRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OpenPTYRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenPTYRequest_EnvEntry>, I>>(base?: I): OpenPTYRequest_EnvEntry {
    return OpenPTYRequest_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenPTYRequest_EnvEntry>, I>>(object: I): OpenPTYRequest_EnvEntry {
    const message = createBaseOpenPTYRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOpenPTYResponse(): OpenPTYResponse {
  return { sessionId: "" };
}

export const OpenPTYResponse: MessageFns<OpenPTYResponse> = {
  encode(message: OpenPTYResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenPTYResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenPTYResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenPTYResponse {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: OpenPTYResponse): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenPTYResponse>, I>>(base?: I): OpenPTYResponse {
    return OpenPTYResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenPTYResponse>, I>>(object: I): OpenPTYResponse {
    const message = createBaseOpenPTYResponse();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBasePTYStreamRequest(): PTYStreamRequest {
  return { sessionId: "" };
}

export const PTYStreamRequest: MessageFns<PTYStreamRequest> = {
  encode(message: PTYStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PTYStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePTYStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PTYStreamRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: PTYStreamRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PTYStreamRequest>, I>>(base?: I): PTYStreamRequest {
    return PTYStreamRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PTYStreamRequest>, I>>(object: I): PTYStreamRequest {
    const message = createBasePTYStreamRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBasePTYOutputChunk(): PTYOutputChunk {
  return { timestamp: undefined, data: new Uint8Array(0) };
}

export const PTYOutputChunk: MessageFns<PTYOutputChunk> = {
  encode(message: PTYOutputChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PTYOutputChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePTYOutputChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PTYOutputChunk {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: PTYOutputChunk): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PTYOutputChunk>, I>>(base?: I): PTYOutputChunk {
    return PTYOutputChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PTYOutputChunk>, I>>(object: I): PTYOutputChunk {
    const message = createBasePTYOutputChunk();
    message.timestamp = object.timestamp ?? undefined;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBasePTYWriteRequest(): PTYWriteRequest {
  return { sessionId: "", data: new Uint8Array(0) };
}

export const PTYWriteRequest: MessageFns<PTYWriteRequest> = {
  encode(message: PTYWriteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PTYWriteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePTYWriteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PTYWriteRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: PTYWriteRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PTYWriteRequest>, I>>(base?: I): PTYWriteRequest {
    return PTYWriteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PTYWriteRequest>, I>>(object: I): PTYWriteRequest {
    const message = createBasePTYWriteRequest();
    message.sessionId = object.sessionId ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBasePTYResizeRequest(): PTYResizeRequest {
  return { sessionId: "", cols: 0, rows: 0 };
}

export const PTYResizeRequest: MessageFns<PTYResizeRequest> = {
  encode(message: PTYResizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.cols !== 0) {
      writer.uint32(16).uint32(message.cols);
    }
    if (message.rows !== 0) {
      writer.uint32(24).uint32(message.rows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PTYResizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePTYResizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cols = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rows = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PTYResizeRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      cols: isSet(object.cols) ? globalThis.Number(object.cols) : 0,
      rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
    };
  },

  toJSON(message: PTYResizeRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.cols !== 0) {
      obj.cols = Math.round(message.cols);
    }
    if (message.rows !== 0) {
      obj.rows = Math.round(message.rows);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PTYResizeRequest>, I>>(base?: I): PTYResizeRequest {
    return PTYResizeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PTYResizeRequest>, I>>(object: I): PTYResizeRequest {
    const message = createBasePTYResizeRequest();
    message.sessionId = object.sessionId ?? "";
    message.cols = object.cols ?? 0;
    message.rows = object.rows ?? 0;
    return message;
  },
};

function createBasePTYCloseRequest(): PTYCloseRequest {
  return { sessionId: "" };
}

export const PTYCloseRequest: MessageFns<PTYCloseRequest> = {
  encode(message: PTYCloseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PTYCloseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePTYCloseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PTYCloseRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: PTYCloseRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PTYCloseRequest>, I>>(base?: I): PTYCloseRequest {
    return PTYCloseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PTYCloseRequest>, I>>(object: I): PTYCloseRequest {
    const message = createBasePTYCloseRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseEnsureShellSessionRequest(): EnsureShellSessionRequest {
  return { name: "", shell: "", args: [], cwd: "", env: {}, cols: 0, rows: 0 };
}

export const EnsureShellSessionRequest: MessageFns<EnsureShellSessionRequest> = {
  encode(message: EnsureShellSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.shell !== "") {
      writer.uint32(18).string(message.shell);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    if (message.cwd !== "") {
      writer.uint32(34).string(message.cwd);
    }
    Object.entries(message.env).forEach(([key, value]) => {
      EnsureShellSessionRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.cols !== 0) {
      writer.uint32(48).uint32(message.cols);
    }
    if (message.rows !== 0) {
      writer.uint32(56).uint32(message.rows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnsureShellSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnsureShellSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shell = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = EnsureShellSessionRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.env[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cols = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rows = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnsureShellSessionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      shell: isSet(object.shell) ? globalThis.String(object.shell) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : "",
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      cols: isSet(object.cols) ? globalThis.Number(object.cols) : 0,
      rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
    };
  },

  toJSON(message: EnsureShellSessionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.shell !== "") {
      obj.shell = message.shell;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.cwd !== "") {
      obj.cwd = message.cwd;
    }
    if (message.env) {
      const entries = Object.entries(message.env);
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.cols !== 0) {
      obj.cols = Math.round(message.cols);
    }
    if (message.rows !== 0) {
      obj.rows = Math.round(message.rows);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnsureShellSessionRequest>, I>>(base?: I): EnsureShellSessionRequest {
    return EnsureShellSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnsureShellSessionRequest>, I>>(object: I): EnsureShellSessionRequest {
    const message = createBaseEnsureShellSessionRequest();
    message.name = object.name ?? "";
    message.shell = object.shell ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.cwd = object.cwd ?? "";
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.cols = object.cols ?? 0;
    message.rows = object.rows ?? 0;
    return message;
  },
};

function createBaseEnsureShellSessionRequest_EnvEntry(): EnsureShellSessionRequest_EnvEntry {
  return { key: "", value: "" };
}

export const EnsureShellSessionRequest_EnvEntry: MessageFns<EnsureShellSessionRequest_EnvEntry> = {
  encode(message: EnsureShellSessionRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnsureShellSessionRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnsureShellSessionRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnsureShellSessionRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EnsureShellSessionRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnsureShellSessionRequest_EnvEntry>, I>>(
    base?: I,
  ): EnsureShellSessionRequest_EnvEntry {
    return EnsureShellSessionRequest_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnsureShellSessionRequest_EnvEntry>, I>>(
    object: I,
  ): EnsureShellSessionRequest_EnvEntry {
    const message = createBaseEnsureShellSessionRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEnsureShellSessionResponse(): EnsureShellSessionResponse {
  return { name: "", logSize: 0 };
}

export const EnsureShellSessionResponse: MessageFns<EnsureShellSessionResponse> = {
  encode(message: EnsureShellSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.logSize !== 0) {
      writer.uint32(16).uint64(message.logSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnsureShellSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnsureShellSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.logSize = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnsureShellSessionResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      logSize: isSet(object.logSize) ? globalThis.Number(object.logSize) : 0,
    };
  },

  toJSON(message: EnsureShellSessionResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.logSize !== 0) {
      obj.logSize = Math.round(message.logSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnsureShellSessionResponse>, I>>(base?: I): EnsureShellSessionResponse {
    return EnsureShellSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnsureShellSessionResponse>, I>>(object: I): EnsureShellSessionResponse {
    const message = createBaseEnsureShellSessionResponse();
    message.name = object.name ?? "";
    message.logSize = object.logSize ?? 0;
    return message;
  },
};

function createBaseShellStreamRequest(): ShellStreamRequest {
  return { name: "", offset: 0, follow: false, maxChunkBytes: 0, pollMs: 0 };
}

export const ShellStreamRequest: MessageFns<ShellStreamRequest> = {
  encode(message: ShellStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.follow !== false) {
      writer.uint32(24).bool(message.follow);
    }
    if (message.maxChunkBytes !== 0) {
      writer.uint32(32).uint32(message.maxChunkBytes);
    }
    if (message.pollMs !== 0) {
      writer.uint32(40).uint32(message.pollMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.follow = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxChunkBytes = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pollMs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellStreamRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      follow: isSet(object.follow) ? globalThis.Boolean(object.follow) : false,
      maxChunkBytes: isSet(object.maxChunkBytes) ? globalThis.Number(object.maxChunkBytes) : 0,
      pollMs: isSet(object.pollMs) ? globalThis.Number(object.pollMs) : 0,
    };
  },

  toJSON(message: ShellStreamRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.follow !== false) {
      obj.follow = message.follow;
    }
    if (message.maxChunkBytes !== 0) {
      obj.maxChunkBytes = Math.round(message.maxChunkBytes);
    }
    if (message.pollMs !== 0) {
      obj.pollMs = Math.round(message.pollMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellStreamRequest>, I>>(base?: I): ShellStreamRequest {
    return ShellStreamRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellStreamRequest>, I>>(object: I): ShellStreamRequest {
    const message = createBaseShellStreamRequest();
    message.name = object.name ?? "";
    message.offset = object.offset ?? 0;
    message.follow = object.follow ?? false;
    message.maxChunkBytes = object.maxChunkBytes ?? 0;
    message.pollMs = object.pollMs ?? 0;
    return message;
  },
};

function createBaseShellOutputChunk(): ShellOutputChunk {
  return { timestamp: undefined, offset: 0, data: new Uint8Array(0) };
}

export const ShellOutputChunk: MessageFns<ShellOutputChunk> = {
  encode(message: ShellOutputChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellOutputChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellOutputChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellOutputChunk {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ShellOutputChunk): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellOutputChunk>, I>>(base?: I): ShellOutputChunk {
    return ShellOutputChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellOutputChunk>, I>>(object: I): ShellOutputChunk {
    const message = createBaseShellOutputChunk();
    message.timestamp = object.timestamp ?? undefined;
    message.offset = object.offset ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseShellWriteRequest(): ShellWriteRequest {
  return { name: "", data: new Uint8Array(0) };
}

export const ShellWriteRequest: MessageFns<ShellWriteRequest> = {
  encode(message: ShellWriteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellWriteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellWriteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellWriteRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ShellWriteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellWriteRequest>, I>>(base?: I): ShellWriteRequest {
    return ShellWriteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellWriteRequest>, I>>(object: I): ShellWriteRequest {
    const message = createBaseShellWriteRequest();
    message.name = object.name ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseShellResizeRequest(): ShellResizeRequest {
  return { name: "", cols: 0, rows: 0 };
}

export const ShellResizeRequest: MessageFns<ShellResizeRequest> = {
  encode(message: ShellResizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.cols !== 0) {
      writer.uint32(16).uint32(message.cols);
    }
    if (message.rows !== 0) {
      writer.uint32(24).uint32(message.rows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellResizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellResizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cols = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rows = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellResizeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cols: isSet(object.cols) ? globalThis.Number(object.cols) : 0,
      rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
    };
  },

  toJSON(message: ShellResizeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cols !== 0) {
      obj.cols = Math.round(message.cols);
    }
    if (message.rows !== 0) {
      obj.rows = Math.round(message.rows);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellResizeRequest>, I>>(base?: I): ShellResizeRequest {
    return ShellResizeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellResizeRequest>, I>>(object: I): ShellResizeRequest {
    const message = createBaseShellResizeRequest();
    message.name = object.name ?? "";
    message.cols = object.cols ?? 0;
    message.rows = object.rows ?? 0;
    return message;
  },
};

function createBaseShellCloseRequest(): ShellCloseRequest {
  return { name: "", kill: false };
}

export const ShellCloseRequest: MessageFns<ShellCloseRequest> = {
  encode(message: ShellCloseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.kill !== false) {
      writer.uint32(16).bool(message.kill);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellCloseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellCloseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kill = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellCloseRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      kill: isSet(object.kill) ? globalThis.Boolean(object.kill) : false,
    };
  },

  toJSON(message: ShellCloseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.kill !== false) {
      obj.kill = message.kill;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellCloseRequest>, I>>(base?: I): ShellCloseRequest {
    return ShellCloseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellCloseRequest>, I>>(object: I): ShellCloseRequest {
    const message = createBaseShellCloseRequest();
    message.name = object.name ?? "";
    message.kill = object.kill ?? false;
    return message;
  },
};

function createBaseShellTailRequest(): ShellTailRequest {
  return { name: "", lines: 0, maxBytes: 0 };
}

export const ShellTailRequest: MessageFns<ShellTailRequest> = {
  encode(message: ShellTailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.lines !== 0) {
      writer.uint32(16).uint32(message.lines);
    }
    if (message.maxBytes !== 0) {
      writer.uint32(24).uint32(message.maxBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellTailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellTailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lines = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxBytes = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellTailRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      lines: isSet(object.lines) ? globalThis.Number(object.lines) : 0,
      maxBytes: isSet(object.maxBytes) ? globalThis.Number(object.maxBytes) : 0,
    };
  },

  toJSON(message: ShellTailRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.lines !== 0) {
      obj.lines = Math.round(message.lines);
    }
    if (message.maxBytes !== 0) {
      obj.maxBytes = Math.round(message.maxBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellTailRequest>, I>>(base?: I): ShellTailRequest {
    return ShellTailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellTailRequest>, I>>(object: I): ShellTailRequest {
    const message = createBaseShellTailRequest();
    message.name = object.name ?? "";
    message.lines = object.lines ?? 0;
    message.maxBytes = object.maxBytes ?? 0;
    return message;
  },
};

function createBaseShellTailResponse(): ShellTailResponse {
  return { name: "", data: new Uint8Array(0), logSize: 0 };
}

export const ShellTailResponse: MessageFns<ShellTailResponse> = {
  encode(message: ShellTailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.logSize !== 0) {
      writer.uint32(24).uint64(message.logSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellTailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellTailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.logSize = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellTailResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      logSize: isSet(object.logSize) ? globalThis.Number(object.logSize) : 0,
    };
  },

  toJSON(message: ShellTailResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.logSize !== 0) {
      obj.logSize = Math.round(message.logSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellTailResponse>, I>>(base?: I): ShellTailResponse {
    return ShellTailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellTailResponse>, I>>(object: I): ShellTailResponse {
    const message = createBaseShellTailResponse();
    message.name = object.name ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.logSize = object.logSize ?? 0;
    return message;
  },
};

function createBaseShellRunRequest(): ShellRunRequest {
  return { name: "", command: "", commandId: "", timeoutMs: 0 };
}

export const ShellRunRequest: MessageFns<ShellRunRequest> = {
  encode(message: ShellRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    if (message.commandId !== "") {
      writer.uint32(26).string(message.commandId);
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(32).uint32(message.timeoutMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timeoutMs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellRunRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
    };
  },

  toJSON(message: ShellRunRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellRunRequest>, I>>(base?: I): ShellRunRequest {
    return ShellRunRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellRunRequest>, I>>(object: I): ShellRunRequest {
    const message = createBaseShellRunRequest();
    message.name = object.name ?? "";
    message.command = object.command ?? "";
    message.commandId = object.commandId ?? "";
    message.timeoutMs = object.timeoutMs ?? 0;
    return message;
  },
};

function createBaseShellRunResponse(): ShellRunResponse {
  return {
    name: "",
    commandId: "",
    exitCode: 0,
    beginOffset: 0,
    endOffset: 0,
    startedAt: undefined,
    completedAt: undefined,
  };
}

export const ShellRunResponse: MessageFns<ShellRunResponse> = {
  encode(message: ShellRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.commandId !== "") {
      writer.uint32(18).string(message.commandId);
    }
    if (message.exitCode !== 0) {
      writer.uint32(24).int32(message.exitCode);
    }
    if (message.beginOffset !== 0) {
      writer.uint32(32).uint64(message.beginOffset);
    }
    if (message.endOffset !== 0) {
      writer.uint32(40).uint64(message.endOffset);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(50).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.beginOffset = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.endOffset = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellRunResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      beginOffset: isSet(object.beginOffset) ? globalThis.Number(object.beginOffset) : 0,
      endOffset: isSet(object.endOffset) ? globalThis.Number(object.endOffset) : 0,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
    };
  },

  toJSON(message: ShellRunResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.beginOffset !== 0) {
      obj.beginOffset = Math.round(message.beginOffset);
    }
    if (message.endOffset !== 0) {
      obj.endOffset = Math.round(message.endOffset);
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellRunResponse>, I>>(base?: I): ShellRunResponse {
    return ShellRunResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellRunResponse>, I>>(object: I): ShellRunResponse {
    const message = createBaseShellRunResponse();
    message.name = object.name ?? "";
    message.commandId = object.commandId ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.beginOffset = object.beginOffset ?? 0;
    message.endOffset = object.endOffset ?? 0;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    return message;
  },
};

function createBaseShellClientHello(): ShellClientHello {
  return {
    name: "",
    afterOffset: 0,
    clientId: "",
    resumeFromLastAck: false,
    maxChunkBytes: 0,
    pollMs: 0,
    compression: 0,
  };
}

export const ShellClientHello: MessageFns<ShellClientHello> = {
  encode(message: ShellClientHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.afterOffset !== 0) {
      writer.uint32(16).uint64(message.afterOffset);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.resumeFromLastAck !== false) {
      writer.uint32(32).bool(message.resumeFromLastAck);
    }
    if (message.maxChunkBytes !== 0) {
      writer.uint32(40).uint32(message.maxChunkBytes);
    }
    if (message.pollMs !== 0) {
      writer.uint32(48).uint32(message.pollMs);
    }
    if (message.compression !== 0) {
      writer.uint32(56).int32(message.compression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellClientHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellClientHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.afterOffset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.resumeFromLastAck = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxChunkBytes = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pollMs = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.compression = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellClientHello {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      afterOffset: isSet(object.afterOffset) ? globalThis.Number(object.afterOffset) : 0,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      resumeFromLastAck: isSet(object.resumeFromLastAck) ? globalThis.Boolean(object.resumeFromLastAck) : false,
      maxChunkBytes: isSet(object.maxChunkBytes) ? globalThis.Number(object.maxChunkBytes) : 0,
      pollMs: isSet(object.pollMs) ? globalThis.Number(object.pollMs) : 0,
      compression: isSet(object.compression) ? shellClientHello_CompressionFromJSON(object.compression) : 0,
    };
  },

  toJSON(message: ShellClientHello): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.afterOffset !== 0) {
      obj.afterOffset = Math.round(message.afterOffset);
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.resumeFromLastAck !== false) {
      obj.resumeFromLastAck = message.resumeFromLastAck;
    }
    if (message.maxChunkBytes !== 0) {
      obj.maxChunkBytes = Math.round(message.maxChunkBytes);
    }
    if (message.pollMs !== 0) {
      obj.pollMs = Math.round(message.pollMs);
    }
    if (message.compression !== 0) {
      obj.compression = shellClientHello_CompressionToJSON(message.compression);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellClientHello>, I>>(base?: I): ShellClientHello {
    return ShellClientHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellClientHello>, I>>(object: I): ShellClientHello {
    const message = createBaseShellClientHello();
    message.name = object.name ?? "";
    message.afterOffset = object.afterOffset ?? 0;
    message.clientId = object.clientId ?? "";
    message.resumeFromLastAck = object.resumeFromLastAck ?? false;
    message.maxChunkBytes = object.maxChunkBytes ?? 0;
    message.pollMs = object.pollMs ?? 0;
    message.compression = object.compression ?? 0;
    return message;
  },
};

function createBaseShellClientAck(): ShellClientAck {
  return { name: "", clientId: "", ackOffset: 0 };
}

export const ShellClientAck: MessageFns<ShellClientAck> = {
  encode(message: ShellClientAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.ackOffset !== 0) {
      writer.uint32(24).uint64(message.ackOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellClientAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellClientAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ackOffset = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellClientAck {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      ackOffset: isSet(object.ackOffset) ? globalThis.Number(object.ackOffset) : 0,
    };
  },

  toJSON(message: ShellClientAck): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.ackOffset !== 0) {
      obj.ackOffset = Math.round(message.ackOffset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellClientAck>, I>>(base?: I): ShellClientAck {
    return ShellClientAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellClientAck>, I>>(object: I): ShellClientAck {
    const message = createBaseShellClientAck();
    message.name = object.name ?? "";
    message.clientId = object.clientId ?? "";
    message.ackOffset = object.ackOffset ?? 0;
    return message;
  },
};

function createBaseShellClientInput(): ShellClientInput {
  return { name: "", data: new Uint8Array(0) };
}

export const ShellClientInput: MessageFns<ShellClientInput> = {
  encode(message: ShellClientInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellClientInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellClientInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellClientInput {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ShellClientInput): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellClientInput>, I>>(base?: I): ShellClientInput {
    return ShellClientInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellClientInput>, I>>(object: I): ShellClientInput {
    const message = createBaseShellClientInput();
    message.name = object.name ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseShellClientResize(): ShellClientResize {
  return { name: "", cols: 0, rows: 0 };
}

export const ShellClientResize: MessageFns<ShellClientResize> = {
  encode(message: ShellClientResize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.cols !== 0) {
      writer.uint32(16).uint32(message.cols);
    }
    if (message.rows !== 0) {
      writer.uint32(24).uint32(message.rows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellClientResize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellClientResize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cols = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rows = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellClientResize {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cols: isSet(object.cols) ? globalThis.Number(object.cols) : 0,
      rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
    };
  },

  toJSON(message: ShellClientResize): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cols !== 0) {
      obj.cols = Math.round(message.cols);
    }
    if (message.rows !== 0) {
      obj.rows = Math.round(message.rows);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellClientResize>, I>>(base?: I): ShellClientResize {
    return ShellClientResize.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellClientResize>, I>>(object: I): ShellClientResize {
    const message = createBaseShellClientResize();
    message.name = object.name ?? "";
    message.cols = object.cols ?? 0;
    message.rows = object.rows ?? 0;
    return message;
  },
};

function createBaseShellClientRun(): ShellClientRun {
  return { name: "", command: "", commandId: "", timeoutMs: 0 };
}

export const ShellClientRun: MessageFns<ShellClientRun> = {
  encode(message: ShellClientRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    if (message.commandId !== "") {
      writer.uint32(26).string(message.commandId);
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(32).uint32(message.timeoutMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellClientRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellClientRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timeoutMs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellClientRun {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
    };
  },

  toJSON(message: ShellClientRun): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellClientRun>, I>>(base?: I): ShellClientRun {
    return ShellClientRun.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellClientRun>, I>>(object: I): ShellClientRun {
    const message = createBaseShellClientRun();
    message.name = object.name ?? "";
    message.command = object.command ?? "";
    message.commandId = object.commandId ?? "";
    message.timeoutMs = object.timeoutMs ?? 0;
    return message;
  },
};

function createBaseShellClientClose(): ShellClientClose {
  return { name: "", kill: false };
}

export const ShellClientClose: MessageFns<ShellClientClose> = {
  encode(message: ShellClientClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.kill !== false) {
      writer.uint32(16).bool(message.kill);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellClientClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellClientClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kill = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellClientClose {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      kill: isSet(object.kill) ? globalThis.Boolean(object.kill) : false,
    };
  },

  toJSON(message: ShellClientClose): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.kill !== false) {
      obj.kill = message.kill;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellClientClose>, I>>(base?: I): ShellClientClose {
    return ShellClientClose.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellClientClose>, I>>(object: I): ShellClientClose {
    const message = createBaseShellClientClose();
    message.name = object.name ?? "";
    message.kill = object.kill ?? false;
    return message;
  },
};

function createBaseShellClientMsg(): ShellClientMsg {
  return { hello: undefined, ack: undefined, input: undefined, resize: undefined, run: undefined, close: undefined };
}

export const ShellClientMsg: MessageFns<ShellClientMsg> = {
  encode(message: ShellClientMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hello !== undefined) {
      ShellClientHello.encode(message.hello, writer.uint32(10).fork()).join();
    }
    if (message.ack !== undefined) {
      ShellClientAck.encode(message.ack, writer.uint32(18).fork()).join();
    }
    if (message.input !== undefined) {
      ShellClientInput.encode(message.input, writer.uint32(26).fork()).join();
    }
    if (message.resize !== undefined) {
      ShellClientResize.encode(message.resize, writer.uint32(34).fork()).join();
    }
    if (message.run !== undefined) {
      ShellClientRun.encode(message.run, writer.uint32(42).fork()).join();
    }
    if (message.close !== undefined) {
      ShellClientClose.encode(message.close, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellClientMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellClientMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hello = ShellClientHello.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ack = ShellClientAck.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.input = ShellClientInput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resize = ShellClientResize.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.run = ShellClientRun.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.close = ShellClientClose.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellClientMsg {
    return {
      hello: isSet(object.hello) ? ShellClientHello.fromJSON(object.hello) : undefined,
      ack: isSet(object.ack) ? ShellClientAck.fromJSON(object.ack) : undefined,
      input: isSet(object.input) ? ShellClientInput.fromJSON(object.input) : undefined,
      resize: isSet(object.resize) ? ShellClientResize.fromJSON(object.resize) : undefined,
      run: isSet(object.run) ? ShellClientRun.fromJSON(object.run) : undefined,
      close: isSet(object.close) ? ShellClientClose.fromJSON(object.close) : undefined,
    };
  },

  toJSON(message: ShellClientMsg): unknown {
    const obj: any = {};
    if (message.hello !== undefined) {
      obj.hello = ShellClientHello.toJSON(message.hello);
    }
    if (message.ack !== undefined) {
      obj.ack = ShellClientAck.toJSON(message.ack);
    }
    if (message.input !== undefined) {
      obj.input = ShellClientInput.toJSON(message.input);
    }
    if (message.resize !== undefined) {
      obj.resize = ShellClientResize.toJSON(message.resize);
    }
    if (message.run !== undefined) {
      obj.run = ShellClientRun.toJSON(message.run);
    }
    if (message.close !== undefined) {
      obj.close = ShellClientClose.toJSON(message.close);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellClientMsg>, I>>(base?: I): ShellClientMsg {
    return ShellClientMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellClientMsg>, I>>(object: I): ShellClientMsg {
    const message = createBaseShellClientMsg();
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? ShellClientHello.fromPartial(object.hello)
      : undefined;
    message.ack = (object.ack !== undefined && object.ack !== null)
      ? ShellClientAck.fromPartial(object.ack)
      : undefined;
    message.input = (object.input !== undefined && object.input !== null)
      ? ShellClientInput.fromPartial(object.input)
      : undefined;
    message.resize = (object.resize !== undefined && object.resize !== null)
      ? ShellClientResize.fromPartial(object.resize)
      : undefined;
    message.run = (object.run !== undefined && object.run !== null)
      ? ShellClientRun.fromPartial(object.run)
      : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? ShellClientClose.fromPartial(object.close)
      : undefined;
    return message;
  },
};

function createBaseShellServerHello(): ShellServerHello {
  return { name: "", startOffset: 0, logSize: 0, compression: 0 };
}

export const ShellServerHello: MessageFns<ShellServerHello> = {
  encode(message: ShellServerHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.startOffset !== 0) {
      writer.uint32(16).uint64(message.startOffset);
    }
    if (message.logSize !== 0) {
      writer.uint32(24).uint64(message.logSize);
    }
    if (message.compression !== 0) {
      writer.uint32(32).int32(message.compression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellServerHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellServerHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startOffset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.logSize = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.compression = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellServerHello {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startOffset: isSet(object.startOffset) ? globalThis.Number(object.startOffset) : 0,
      logSize: isSet(object.logSize) ? globalThis.Number(object.logSize) : 0,
      compression: isSet(object.compression) ? shellClientHello_CompressionFromJSON(object.compression) : 0,
    };
  },

  toJSON(message: ShellServerHello): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startOffset !== 0) {
      obj.startOffset = Math.round(message.startOffset);
    }
    if (message.logSize !== 0) {
      obj.logSize = Math.round(message.logSize);
    }
    if (message.compression !== 0) {
      obj.compression = shellClientHello_CompressionToJSON(message.compression);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellServerHello>, I>>(base?: I): ShellServerHello {
    return ShellServerHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellServerHello>, I>>(object: I): ShellServerHello {
    const message = createBaseShellServerHello();
    message.name = object.name ?? "";
    message.startOffset = object.startOffset ?? 0;
    message.logSize = object.logSize ?? 0;
    message.compression = object.compression ?? 0;
    return message;
  },
};

function createBaseShellServerChunk(): ShellServerChunk {
  return { name: "", offset: 0, data: new Uint8Array(0), uncompressedLen: 0 };
}

export const ShellServerChunk: MessageFns<ShellServerChunk> = {
  encode(message: ShellServerChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.uncompressedLen !== 0) {
      writer.uint32(32).uint32(message.uncompressedLen);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellServerChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellServerChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uncompressedLen = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellServerChunk {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      uncompressedLen: isSet(object.uncompressedLen) ? globalThis.Number(object.uncompressedLen) : 0,
    };
  },

  toJSON(message: ShellServerChunk): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.uncompressedLen !== 0) {
      obj.uncompressedLen = Math.round(message.uncompressedLen);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellServerChunk>, I>>(base?: I): ShellServerChunk {
    return ShellServerChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellServerChunk>, I>>(object: I): ShellServerChunk {
    const message = createBaseShellServerChunk();
    message.name = object.name ?? "";
    message.offset = object.offset ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.uncompressedLen = object.uncompressedLen ?? 0;
    return message;
  },
};

function createBaseShellServerCommandEvent(): ShellServerCommandEvent {
  return { name: "", record: undefined, phase: 0 };
}

export const ShellServerCommandEvent: MessageFns<ShellServerCommandEvent> = {
  encode(message: ShellServerCommandEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.record !== undefined) {
      ShellCommandRecord.encode(message.record, writer.uint32(18).fork()).join();
    }
    if (message.phase !== 0) {
      writer.uint32(24).int32(message.phase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellServerCommandEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellServerCommandEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.record = ShellCommandRecord.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellServerCommandEvent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      record: isSet(object.record) ? ShellCommandRecord.fromJSON(object.record) : undefined,
      phase: isSet(object.phase) ? shellServerCommandEvent_PhaseFromJSON(object.phase) : 0,
    };
  },

  toJSON(message: ShellServerCommandEvent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.record !== undefined) {
      obj.record = ShellCommandRecord.toJSON(message.record);
    }
    if (message.phase !== 0) {
      obj.phase = shellServerCommandEvent_PhaseToJSON(message.phase);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellServerCommandEvent>, I>>(base?: I): ShellServerCommandEvent {
    return ShellServerCommandEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellServerCommandEvent>, I>>(object: I): ShellServerCommandEvent {
    const message = createBaseShellServerCommandEvent();
    message.name = object.name ?? "";
    message.record = (object.record !== undefined && object.record !== null)
      ? ShellCommandRecord.fromPartial(object.record)
      : undefined;
    message.phase = object.phase ?? 0;
    return message;
  },
};

function createBaseShellServerMsg(): ShellServerMsg {
  return { hello: undefined, chunk: undefined, command: undefined };
}

export const ShellServerMsg: MessageFns<ShellServerMsg> = {
  encode(message: ShellServerMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hello !== undefined) {
      ShellServerHello.encode(message.hello, writer.uint32(10).fork()).join();
    }
    if (message.chunk !== undefined) {
      ShellServerChunk.encode(message.chunk, writer.uint32(18).fork()).join();
    }
    if (message.command !== undefined) {
      ShellServerCommandEvent.encode(message.command, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellServerMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellServerMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hello = ShellServerHello.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chunk = ShellServerChunk.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.command = ShellServerCommandEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellServerMsg {
    return {
      hello: isSet(object.hello) ? ShellServerHello.fromJSON(object.hello) : undefined,
      chunk: isSet(object.chunk) ? ShellServerChunk.fromJSON(object.chunk) : undefined,
      command: isSet(object.command) ? ShellServerCommandEvent.fromJSON(object.command) : undefined,
    };
  },

  toJSON(message: ShellServerMsg): unknown {
    const obj: any = {};
    if (message.hello !== undefined) {
      obj.hello = ShellServerHello.toJSON(message.hello);
    }
    if (message.chunk !== undefined) {
      obj.chunk = ShellServerChunk.toJSON(message.chunk);
    }
    if (message.command !== undefined) {
      obj.command = ShellServerCommandEvent.toJSON(message.command);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellServerMsg>, I>>(base?: I): ShellServerMsg {
    return ShellServerMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellServerMsg>, I>>(object: I): ShellServerMsg {
    const message = createBaseShellServerMsg();
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? ShellServerHello.fromPartial(object.hello)
      : undefined;
    message.chunk = (object.chunk !== undefined && object.chunk !== null)
      ? ShellServerChunk.fromPartial(object.chunk)
      : undefined;
    message.command = (object.command !== undefined && object.command !== null)
      ? ShellServerCommandEvent.fromPartial(object.command)
      : undefined;
    return message;
  },
};

function createBaseShellCommandRecord(): ShellCommandRecord {
  return {
    name: "",
    commandId: "",
    command: "",
    exitCode: 0,
    beginOffset: 0,
    endOffset: 0,
    startedAt: undefined,
    completedAt: undefined,
    outputBytes: 0,
    artifactIds: [],
  };
}

export const ShellCommandRecord: MessageFns<ShellCommandRecord> = {
  encode(message: ShellCommandRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.commandId !== "") {
      writer.uint32(18).string(message.commandId);
    }
    if (message.command !== "") {
      writer.uint32(26).string(message.command);
    }
    if (message.exitCode !== 0) {
      writer.uint32(32).int32(message.exitCode);
    }
    if (message.beginOffset !== 0) {
      writer.uint32(40).uint64(message.beginOffset);
    }
    if (message.endOffset !== 0) {
      writer.uint32(48).uint64(message.endOffset);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(58).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(66).fork()).join();
    }
    if (message.outputBytes !== 0) {
      writer.uint32(72).uint64(message.outputBytes);
    }
    for (const v of message.artifactIds) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellCommandRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellCommandRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.beginOffset = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.endOffset = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.outputBytes = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.artifactIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellCommandRecord {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      beginOffset: isSet(object.beginOffset) ? globalThis.Number(object.beginOffset) : 0,
      endOffset: isSet(object.endOffset) ? globalThis.Number(object.endOffset) : 0,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
      outputBytes: isSet(object.outputBytes) ? globalThis.Number(object.outputBytes) : 0,
      artifactIds: globalThis.Array.isArray(object?.artifactIds)
        ? object.artifactIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ShellCommandRecord): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.beginOffset !== 0) {
      obj.beginOffset = Math.round(message.beginOffset);
    }
    if (message.endOffset !== 0) {
      obj.endOffset = Math.round(message.endOffset);
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.outputBytes !== 0) {
      obj.outputBytes = Math.round(message.outputBytes);
    }
    if (message.artifactIds?.length) {
      obj.artifactIds = message.artifactIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellCommandRecord>, I>>(base?: I): ShellCommandRecord {
    return ShellCommandRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellCommandRecord>, I>>(object: I): ShellCommandRecord {
    const message = createBaseShellCommandRecord();
    message.name = object.name ?? "";
    message.commandId = object.commandId ?? "";
    message.command = object.command ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.beginOffset = object.beginOffset ?? 0;
    message.endOffset = object.endOffset ?? 0;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.outputBytes = object.outputBytes ?? 0;
    message.artifactIds = object.artifactIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseShellArtifact(): ShellArtifact {
  return { id: "", name: "", commandId: "", type: "", title: "", dataJson: new Uint8Array(0), createdAt: undefined };
}

export const ShellArtifact: MessageFns<ShellArtifact> = {
  encode(message: ShellArtifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.commandId !== "") {
      writer.uint32(26).string(message.commandId);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.dataJson.length !== 0) {
      writer.uint32(50).bytes(message.dataJson);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dataJson = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellArtifact {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      dataJson: isSet(object.dataJson) ? bytesFromBase64(object.dataJson) : new Uint8Array(0),
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: ShellArtifact): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.dataJson.length !== 0) {
      obj.dataJson = base64FromBytes(message.dataJson);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellArtifact>, I>>(base?: I): ShellArtifact {
    return ShellArtifact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellArtifact>, I>>(object: I): ShellArtifact {
    const message = createBaseShellArtifact();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.commandId = object.commandId ?? "";
    message.type = object.type ?? "";
    message.title = object.title ?? "";
    message.dataJson = object.dataJson ?? new Uint8Array(0);
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseListShellArtifactsRequest(): ListShellArtifactsRequest {
  return { name: "", commandId: "", limit: 0 };
}

export const ListShellArtifactsRequest: MessageFns<ListShellArtifactsRequest> = {
  encode(message: ListShellArtifactsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.commandId !== "") {
      writer.uint32(18).string(message.commandId);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShellArtifactsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShellArtifactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShellArtifactsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListShellArtifactsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListShellArtifactsRequest>, I>>(base?: I): ListShellArtifactsRequest {
    return ListShellArtifactsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListShellArtifactsRequest>, I>>(object: I): ListShellArtifactsRequest {
    const message = createBaseListShellArtifactsRequest();
    message.name = object.name ?? "";
    message.commandId = object.commandId ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseListShellArtifactsResponse(): ListShellArtifactsResponse {
  return { artifacts: [] };
}

export const ListShellArtifactsResponse: MessageFns<ListShellArtifactsResponse> = {
  encode(message: ListShellArtifactsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.artifacts) {
      ShellArtifact.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShellArtifactsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShellArtifactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(ShellArtifact.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShellArtifactsResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => ShellArtifact.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListShellArtifactsResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => ShellArtifact.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListShellArtifactsResponse>, I>>(base?: I): ListShellArtifactsResponse {
    return ListShellArtifactsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListShellArtifactsResponse>, I>>(object: I): ListShellArtifactsResponse {
    const message = createBaseListShellArtifactsResponse();
    message.artifacts = object.artifacts?.map((e) => ShellArtifact.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListShellCommandsRequest(): ListShellCommandsRequest {
  return { name: "", limit: 0 };
}

export const ListShellCommandsRequest: MessageFns<ListShellCommandsRequest> = {
  encode(message: ListShellCommandsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShellCommandsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShellCommandsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShellCommandsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListShellCommandsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListShellCommandsRequest>, I>>(base?: I): ListShellCommandsRequest {
    return ListShellCommandsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListShellCommandsRequest>, I>>(object: I): ListShellCommandsRequest {
    const message = createBaseListShellCommandsRequest();
    message.name = object.name ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseListShellCommandsResponse(): ListShellCommandsResponse {
  return { commands: [] };
}

export const ListShellCommandsResponse: MessageFns<ListShellCommandsResponse> = {
  encode(message: ListShellCommandsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.commands) {
      ShellCommandRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShellCommandsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShellCommandsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commands.push(ShellCommandRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShellCommandsResponse {
    return {
      commands: globalThis.Array.isArray(object?.commands)
        ? object.commands.map((e: any) => ShellCommandRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListShellCommandsResponse): unknown {
    const obj: any = {};
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => ShellCommandRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListShellCommandsResponse>, I>>(base?: I): ListShellCommandsResponse {
    return ListShellCommandsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListShellCommandsResponse>, I>>(object: I): ListShellCommandsResponse {
    const message = createBaseListShellCommandsResponse();
    message.commands = object.commands?.map((e) => ShellCommandRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShellSearchRequest(): ShellSearchRequest {
  return {
    name: "",
    query: new Uint8Array(0),
    startOffset: 0,
    endOffset: 0,
    commandId: "",
    startTime: undefined,
    endTime: undefined,
    maxMatches: 0,
    contextBytes: 0,
  };
}

export const ShellSearchRequest: MessageFns<ShellSearchRequest> = {
  encode(message: ShellSearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.query.length !== 0) {
      writer.uint32(18).bytes(message.query);
    }
    if (message.startOffset !== 0) {
      writer.uint32(24).uint64(message.startOffset);
    }
    if (message.endOffset !== 0) {
      writer.uint32(32).uint64(message.endOffset);
    }
    if (message.commandId !== "") {
      writer.uint32(42).string(message.commandId);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(58).fork()).join();
    }
    if (message.maxMatches !== 0) {
      writer.uint32(64).uint32(message.maxMatches);
    }
    if (message.contextBytes !== 0) {
      writer.uint32(72).uint32(message.contextBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellSearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startOffset = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endOffset = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxMatches = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.contextBytes = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellSearchRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      query: isSet(object.query) ? bytesFromBase64(object.query) : new Uint8Array(0),
      startOffset: isSet(object.startOffset) ? globalThis.Number(object.startOffset) : 0,
      endOffset: isSet(object.endOffset) ? globalThis.Number(object.endOffset) : 0,
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      maxMatches: isSet(object.maxMatches) ? globalThis.Number(object.maxMatches) : 0,
      contextBytes: isSet(object.contextBytes) ? globalThis.Number(object.contextBytes) : 0,
    };
  },

  toJSON(message: ShellSearchRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.query.length !== 0) {
      obj.query = base64FromBytes(message.query);
    }
    if (message.startOffset !== 0) {
      obj.startOffset = Math.round(message.startOffset);
    }
    if (message.endOffset !== 0) {
      obj.endOffset = Math.round(message.endOffset);
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.maxMatches !== 0) {
      obj.maxMatches = Math.round(message.maxMatches);
    }
    if (message.contextBytes !== 0) {
      obj.contextBytes = Math.round(message.contextBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellSearchRequest>, I>>(base?: I): ShellSearchRequest {
    return ShellSearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellSearchRequest>, I>>(object: I): ShellSearchRequest {
    const message = createBaseShellSearchRequest();
    message.name = object.name ?? "";
    message.query = object.query ?? new Uint8Array(0);
    message.startOffset = object.startOffset ?? 0;
    message.endOffset = object.endOffset ?? 0;
    message.commandId = object.commandId ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.maxMatches = object.maxMatches ?? 0;
    message.contextBytes = object.contextBytes ?? 0;
    return message;
  },
};

function createBaseShellSearchMatch(): ShellSearchMatch {
  return { commandId: "", offset: 0, snippet: new Uint8Array(0) };
}

export const ShellSearchMatch: MessageFns<ShellSearchMatch> = {
  encode(message: ShellSearchMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.snippet.length !== 0) {
      writer.uint32(26).bytes(message.snippet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellSearchMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellSearchMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.snippet = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellSearchMatch {
    return {
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      snippet: isSet(object.snippet) ? bytesFromBase64(object.snippet) : new Uint8Array(0),
    };
  },

  toJSON(message: ShellSearchMatch): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.snippet.length !== 0) {
      obj.snippet = base64FromBytes(message.snippet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellSearchMatch>, I>>(base?: I): ShellSearchMatch {
    return ShellSearchMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellSearchMatch>, I>>(object: I): ShellSearchMatch {
    const message = createBaseShellSearchMatch();
    message.commandId = object.commandId ?? "";
    message.offset = object.offset ?? 0;
    message.snippet = object.snippet ?? new Uint8Array(0);
    return message;
  },
};

function createBaseShellSearchResponse(): ShellSearchResponse {
  return { matches: [], logSize: 0 };
}

export const ShellSearchResponse: MessageFns<ShellSearchResponse> = {
  encode(message: ShellSearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      ShellSearchMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.logSize !== 0) {
      writer.uint32(16).uint64(message.logSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellSearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(ShellSearchMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.logSize = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellSearchResponse {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => ShellSearchMatch.fromJSON(e))
        : [],
      logSize: isSet(object.logSize) ? globalThis.Number(object.logSize) : 0,
    };
  },

  toJSON(message: ShellSearchResponse): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => ShellSearchMatch.toJSON(e));
    }
    if (message.logSize !== 0) {
      obj.logSize = Math.round(message.logSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellSearchResponse>, I>>(base?: I): ShellSearchResponse {
    return ShellSearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellSearchResponse>, I>>(object: I): ShellSearchResponse {
    const message = createBaseShellSearchResponse();
    message.matches = object.matches?.map((e) => ShellSearchMatch.fromPartial(e)) || [];
    message.logSize = object.logSize ?? 0;
    return message;
  },
};

export type RemoteControlServiceService = typeof RemoteControlServiceService;
export const RemoteControlServiceService = {
  ping: {
    path: "/xrunner.v1.RemoteControlService/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  version: {
    path: "/xrunner.v1.RemoteControlService/Version",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: RemoteVersionResponse): Buffer =>
      Buffer.from(RemoteVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RemoteVersionResponse => RemoteVersionResponse.decode(value),
  },
} as const;

export interface RemoteControlServiceServer extends UntypedServiceImplementation {
  ping: handleUnaryCall<Empty, Empty>;
  version: handleUnaryCall<Empty, RemoteVersionResponse>;
}

export interface RemoteControlServiceClient extends Client {
  ping(request: Empty, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  ping(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  ping(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  version(
    request: Empty,
    callback: (error: ServiceError | null, response: RemoteVersionResponse) => void,
  ): ClientUnaryCall;
  version(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RemoteVersionResponse) => void,
  ): ClientUnaryCall;
  version(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RemoteVersionResponse) => void,
  ): ClientUnaryCall;
}

export const RemoteControlServiceClient = makeGenericClientConstructor(
  RemoteControlServiceService,
  "xrunner.v1.RemoteControlService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RemoteControlServiceClient;
  service: typeof RemoteControlServiceService;
  serviceName: string;
};

export type RemoteFileServiceService = typeof RemoteFileServiceService;
export const RemoteFileServiceService = {
  readFile: {
    path: "/xrunner.v1.RemoteFileService/ReadFile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReadFileRequest): Buffer => Buffer.from(ReadFileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReadFileRequest => ReadFileRequest.decode(value),
    responseSerialize: (value: ReadFileResponse): Buffer => Buffer.from(ReadFileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReadFileResponse => ReadFileResponse.decode(value),
  },
  writeFileAtomic: {
    path: "/xrunner.v1.RemoteFileService/WriteFileAtomic",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WriteFileRequest): Buffer => Buffer.from(WriteFileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): WriteFileRequest => WriteFileRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface RemoteFileServiceServer extends UntypedServiceImplementation {
  readFile: handleUnaryCall<ReadFileRequest, ReadFileResponse>;
  writeFileAtomic: handleUnaryCall<WriteFileRequest, Empty>;
}

export interface RemoteFileServiceClient extends Client {
  readFile(
    request: ReadFileRequest,
    callback: (error: ServiceError | null, response: ReadFileResponse) => void,
  ): ClientUnaryCall;
  readFile(
    request: ReadFileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReadFileResponse) => void,
  ): ClientUnaryCall;
  readFile(
    request: ReadFileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReadFileResponse) => void,
  ): ClientUnaryCall;
  writeFileAtomic(
    request: WriteFileRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  writeFileAtomic(
    request: WriteFileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  writeFileAtomic(
    request: WriteFileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const RemoteFileServiceClient = makeGenericClientConstructor(
  RemoteFileServiceService,
  "xrunner.v1.RemoteFileService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RemoteFileServiceClient;
  service: typeof RemoteFileServiceService;
  serviceName: string;
};

export type RemotePTYServiceService = typeof RemotePTYServiceService;
export const RemotePTYServiceService = {
  openPty: {
    path: "/xrunner.v1.RemotePTYService/OpenPTY",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OpenPTYRequest): Buffer => Buffer.from(OpenPTYRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OpenPTYRequest => OpenPTYRequest.decode(value),
    responseSerialize: (value: OpenPTYResponse): Buffer => Buffer.from(OpenPTYResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OpenPTYResponse => OpenPTYResponse.decode(value),
  },
  streamPty: {
    path: "/xrunner.v1.RemotePTYService/StreamPTY",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: PTYStreamRequest): Buffer => Buffer.from(PTYStreamRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PTYStreamRequest => PTYStreamRequest.decode(value),
    responseSerialize: (value: PTYOutputChunk): Buffer => Buffer.from(PTYOutputChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer): PTYOutputChunk => PTYOutputChunk.decode(value),
  },
  writePty: {
    path: "/xrunner.v1.RemotePTYService/WritePTY",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PTYWriteRequest): Buffer => Buffer.from(PTYWriteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PTYWriteRequest => PTYWriteRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  resizePty: {
    path: "/xrunner.v1.RemotePTYService/ResizePTY",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PTYResizeRequest): Buffer => Buffer.from(PTYResizeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PTYResizeRequest => PTYResizeRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  closePty: {
    path: "/xrunner.v1.RemotePTYService/ClosePTY",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PTYCloseRequest): Buffer => Buffer.from(PTYCloseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PTYCloseRequest => PTYCloseRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface RemotePTYServiceServer extends UntypedServiceImplementation {
  openPty: handleUnaryCall<OpenPTYRequest, OpenPTYResponse>;
  streamPty: handleServerStreamingCall<PTYStreamRequest, PTYOutputChunk>;
  writePty: handleUnaryCall<PTYWriteRequest, Empty>;
  resizePty: handleUnaryCall<PTYResizeRequest, Empty>;
  closePty: handleUnaryCall<PTYCloseRequest, Empty>;
}

export interface RemotePTYServiceClient extends Client {
  openPty(
    request: OpenPTYRequest,
    callback: (error: ServiceError | null, response: OpenPTYResponse) => void,
  ): ClientUnaryCall;
  openPty(
    request: OpenPTYRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OpenPTYResponse) => void,
  ): ClientUnaryCall;
  openPty(
    request: OpenPTYRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OpenPTYResponse) => void,
  ): ClientUnaryCall;
  streamPty(request: PTYStreamRequest, options?: Partial<CallOptions>): ClientReadableStream<PTYOutputChunk>;
  streamPty(
    request: PTYStreamRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PTYOutputChunk>;
  writePty(request: PTYWriteRequest, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  writePty(
    request: PTYWriteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  writePty(
    request: PTYWriteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resizePty(
    request: PTYResizeRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resizePty(
    request: PTYResizeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resizePty(
    request: PTYResizeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  closePty(request: PTYCloseRequest, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  closePty(
    request: PTYCloseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  closePty(
    request: PTYCloseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const RemotePTYServiceClient = makeGenericClientConstructor(
  RemotePTYServiceService,
  "xrunner.v1.RemotePTYService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RemotePTYServiceClient;
  service: typeof RemotePTYServiceService;
  serviceName: string;
};

export type RemoteShellServiceService = typeof RemoteShellServiceService;
export const RemoteShellServiceService = {
  ensureShellSession: {
    path: "/xrunner.v1.RemoteShellService/EnsureShellSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EnsureShellSessionRequest): Buffer =>
      Buffer.from(EnsureShellSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): EnsureShellSessionRequest => EnsureShellSessionRequest.decode(value),
    responseSerialize: (value: EnsureShellSessionResponse): Buffer =>
      Buffer.from(EnsureShellSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EnsureShellSessionResponse => EnsureShellSessionResponse.decode(value),
  },
  streamShell: {
    path: "/xrunner.v1.RemoteShellService/StreamShell",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ShellStreamRequest): Buffer => Buffer.from(ShellStreamRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ShellStreamRequest => ShellStreamRequest.decode(value),
    responseSerialize: (value: ShellOutputChunk): Buffer => Buffer.from(ShellOutputChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer): ShellOutputChunk => ShellOutputChunk.decode(value),
  },
  writeShell: {
    path: "/xrunner.v1.RemoteShellService/WriteShell",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShellWriteRequest): Buffer => Buffer.from(ShellWriteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ShellWriteRequest => ShellWriteRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  resizeShell: {
    path: "/xrunner.v1.RemoteShellService/ResizeShell",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShellResizeRequest): Buffer => Buffer.from(ShellResizeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ShellResizeRequest => ShellResizeRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  tailShell: {
    path: "/xrunner.v1.RemoteShellService/TailShell",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShellTailRequest): Buffer => Buffer.from(ShellTailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ShellTailRequest => ShellTailRequest.decode(value),
    responseSerialize: (value: ShellTailResponse): Buffer => Buffer.from(ShellTailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ShellTailResponse => ShellTailResponse.decode(value),
  },
  runShell: {
    path: "/xrunner.v1.RemoteShellService/RunShell",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShellRunRequest): Buffer => Buffer.from(ShellRunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ShellRunRequest => ShellRunRequest.decode(value),
    responseSerialize: (value: ShellRunResponse): Buffer => Buffer.from(ShellRunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ShellRunResponse => ShellRunResponse.decode(value),
  },
  closeShell: {
    path: "/xrunner.v1.RemoteShellService/CloseShell",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShellCloseRequest): Buffer => Buffer.from(ShellCloseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ShellCloseRequest => ShellCloseRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  attachShell: {
    path: "/xrunner.v1.RemoteShellService/AttachShell",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ShellClientMsg): Buffer => Buffer.from(ShellClientMsg.encode(value).finish()),
    requestDeserialize: (value: Buffer): ShellClientMsg => ShellClientMsg.decode(value),
    responseSerialize: (value: ShellServerMsg): Buffer => Buffer.from(ShellServerMsg.encode(value).finish()),
    responseDeserialize: (value: Buffer): ShellServerMsg => ShellServerMsg.decode(value),
  },
  listShellCommands: {
    path: "/xrunner.v1.RemoteShellService/ListShellCommands",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListShellCommandsRequest): Buffer =>
      Buffer.from(ListShellCommandsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListShellCommandsRequest => ListShellCommandsRequest.decode(value),
    responseSerialize: (value: ListShellCommandsResponse): Buffer =>
      Buffer.from(ListShellCommandsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListShellCommandsResponse => ListShellCommandsResponse.decode(value),
  },
  searchShell: {
    path: "/xrunner.v1.RemoteShellService/SearchShell",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShellSearchRequest): Buffer => Buffer.from(ShellSearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ShellSearchRequest => ShellSearchRequest.decode(value),
    responseSerialize: (value: ShellSearchResponse): Buffer => Buffer.from(ShellSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ShellSearchResponse => ShellSearchResponse.decode(value),
  },
  listShellArtifacts: {
    path: "/xrunner.v1.RemoteShellService/ListShellArtifacts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListShellArtifactsRequest): Buffer =>
      Buffer.from(ListShellArtifactsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListShellArtifactsRequest => ListShellArtifactsRequest.decode(value),
    responseSerialize: (value: ListShellArtifactsResponse): Buffer =>
      Buffer.from(ListShellArtifactsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListShellArtifactsResponse => ListShellArtifactsResponse.decode(value),
  },
} as const;

export interface RemoteShellServiceServer extends UntypedServiceImplementation {
  ensureShellSession: handleUnaryCall<EnsureShellSessionRequest, EnsureShellSessionResponse>;
  streamShell: handleServerStreamingCall<ShellStreamRequest, ShellOutputChunk>;
  writeShell: handleUnaryCall<ShellWriteRequest, Empty>;
  resizeShell: handleUnaryCall<ShellResizeRequest, Empty>;
  tailShell: handleUnaryCall<ShellTailRequest, ShellTailResponse>;
  runShell: handleUnaryCall<ShellRunRequest, ShellRunResponse>;
  closeShell: handleUnaryCall<ShellCloseRequest, Empty>;
  attachShell: handleBidiStreamingCall<ShellClientMsg, ShellServerMsg>;
  listShellCommands: handleUnaryCall<ListShellCommandsRequest, ListShellCommandsResponse>;
  searchShell: handleUnaryCall<ShellSearchRequest, ShellSearchResponse>;
  listShellArtifacts: handleUnaryCall<ListShellArtifactsRequest, ListShellArtifactsResponse>;
}

export interface RemoteShellServiceClient extends Client {
  ensureShellSession(
    request: EnsureShellSessionRequest,
    callback: (error: ServiceError | null, response: EnsureShellSessionResponse) => void,
  ): ClientUnaryCall;
  ensureShellSession(
    request: EnsureShellSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EnsureShellSessionResponse) => void,
  ): ClientUnaryCall;
  ensureShellSession(
    request: EnsureShellSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EnsureShellSessionResponse) => void,
  ): ClientUnaryCall;
  streamShell(request: ShellStreamRequest, options?: Partial<CallOptions>): ClientReadableStream<ShellOutputChunk>;
  streamShell(
    request: ShellStreamRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ShellOutputChunk>;
  writeShell(
    request: ShellWriteRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  writeShell(
    request: ShellWriteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  writeShell(
    request: ShellWriteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resizeShell(
    request: ShellResizeRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resizeShell(
    request: ShellResizeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resizeShell(
    request: ShellResizeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  tailShell(
    request: ShellTailRequest,
    callback: (error: ServiceError | null, response: ShellTailResponse) => void,
  ): ClientUnaryCall;
  tailShell(
    request: ShellTailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShellTailResponse) => void,
  ): ClientUnaryCall;
  tailShell(
    request: ShellTailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShellTailResponse) => void,
  ): ClientUnaryCall;
  runShell(
    request: ShellRunRequest,
    callback: (error: ServiceError | null, response: ShellRunResponse) => void,
  ): ClientUnaryCall;
  runShell(
    request: ShellRunRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShellRunResponse) => void,
  ): ClientUnaryCall;
  runShell(
    request: ShellRunRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShellRunResponse) => void,
  ): ClientUnaryCall;
  closeShell(
    request: ShellCloseRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  closeShell(
    request: ShellCloseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  closeShell(
    request: ShellCloseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  attachShell(): ClientDuplexStream<ShellClientMsg, ShellServerMsg>;
  attachShell(options: Partial<CallOptions>): ClientDuplexStream<ShellClientMsg, ShellServerMsg>;
  attachShell(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<ShellClientMsg, ShellServerMsg>;
  listShellCommands(
    request: ListShellCommandsRequest,
    callback: (error: ServiceError | null, response: ListShellCommandsResponse) => void,
  ): ClientUnaryCall;
  listShellCommands(
    request: ListShellCommandsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListShellCommandsResponse) => void,
  ): ClientUnaryCall;
  listShellCommands(
    request: ListShellCommandsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListShellCommandsResponse) => void,
  ): ClientUnaryCall;
  searchShell(
    request: ShellSearchRequest,
    callback: (error: ServiceError | null, response: ShellSearchResponse) => void,
  ): ClientUnaryCall;
  searchShell(
    request: ShellSearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShellSearchResponse) => void,
  ): ClientUnaryCall;
  searchShell(
    request: ShellSearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShellSearchResponse) => void,
  ): ClientUnaryCall;
  listShellArtifacts(
    request: ListShellArtifactsRequest,
    callback: (error: ServiceError | null, response: ListShellArtifactsResponse) => void,
  ): ClientUnaryCall;
  listShellArtifacts(
    request: ListShellArtifactsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListShellArtifactsResponse) => void,
  ): ClientUnaryCall;
  listShellArtifacts(
    request: ListShellArtifactsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListShellArtifactsResponse) => void,
  ): ClientUnaryCall;
}

export const RemoteShellServiceClient = makeGenericClientConstructor(
  RemoteShellServiceService,
  "xrunner.v1.RemoteShellService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RemoteShellServiceClient;
  service: typeof RemoteShellServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
