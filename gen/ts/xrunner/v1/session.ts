// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.2
// source: xrunner/v1/session.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../../google/protobuf/empty";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "xrunner.v1";

export enum EventLane {
  EVENT_LANE_UNSPECIFIED = 0,
  EVENT_LANE_HIGH = 1,
  EVENT_LANE_MEDIUM = 2,
  EVENT_LANE_LOW = 3,
  UNRECOGNIZED = -1,
}

export function eventLaneFromJSON(object: any): EventLane {
  switch (object) {
    case 0:
    case "EVENT_LANE_UNSPECIFIED":
      return EventLane.EVENT_LANE_UNSPECIFIED;
    case 1:
    case "EVENT_LANE_HIGH":
      return EventLane.EVENT_LANE_HIGH;
    case 2:
    case "EVENT_LANE_MEDIUM":
      return EventLane.EVENT_LANE_MEDIUM;
    case 3:
    case "EVENT_LANE_LOW":
      return EventLane.EVENT_LANE_LOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventLane.UNRECOGNIZED;
  }
}

export function eventLaneToJSON(object: EventLane): string {
  switch (object) {
    case EventLane.EVENT_LANE_UNSPECIFIED:
      return "EVENT_LANE_UNSPECIFIED";
    case EventLane.EVENT_LANE_HIGH:
      return "EVENT_LANE_HIGH";
    case EventLane.EVENT_LANE_MEDIUM:
      return "EVENT_LANE_MEDIUM";
    case EventLane.EVENT_LANE_LOW:
      return "EVENT_LANE_LOW";
    case EventLane.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Session {
  sessionId: string;
  workspaceRoot: string;
  toolBundlePath: string;
  createdAt: Date | undefined;
}

export interface CreateSessionRequest {
  workspaceRoot: string;
  toolBundlePath: string;
}

export interface CreateSessionResponse {
  session: Session | undefined;
}

export interface ListSessionsRequest {
}

export interface ListSessionsResponse {
  sessions: Session[];
}

export interface GetSessionRequest {
  sessionId: string;
}

export interface AgentEvent {
  eventId: number;
  timestamp: Date | undefined;
  sessionId: string;
  lane: EventLane;
  sessionStarted?: SessionStarted | undefined;
  userMessage?: UserMessage | undefined;
  assistantMessage?: AssistantMessage | undefined;
  toolCallStarted?: ToolCallStarted | undefined;
  toolOutputChunk?: ToolOutputChunk | undefined;
  toolCallResult?: ToolCallResult | undefined;
  fileDiff?: FileDiff | undefined;
  status?: Status | undefined;
  error?: Error | undefined;
  toolBundleLoaded?: ToolBundleLoaded | undefined;
}

export interface SessionStarted {
  workspaceRoot: string;
  toolBundlePath: string;
}

export interface UserMessage {
  text: string;
}

export interface AssistantMessage {
  text: string;
  markdown: boolean;
}

export interface ToolCallStarted {
  toolCallId: string;
  name: string;
  argsJson: string;
}

export interface ToolOutputChunk {
  toolCallId: string;
  stream: string;
  data: Uint8Array;
}

export interface ToolCallResult {
  toolCallId: string;
  exitCode: number;
  errorMessage: string;
}

export interface FileDiff {
  path: string;
  unifiedDiff: string;
}

export interface Status {
  /** idle|thinking|running_tool */
  phase: string;
  detail: string;
}

export interface Error {
  message: string;
}

export interface ToolBundleLoaded {
  path: string;
  schemaVersion: string;
  bundleVersion: string;
  toolNames: string[];
}

export interface ClientHello {
  sessionId: string;
  afterEventId: number;
}

export interface ClientMsg {
  hello?: ClientHello | undefined;
  userMessage?: UserMessage | undefined;
  toolInvoke?: ToolInvoke | undefined;
  cancel?: Cancel | undefined;
}

export interface ToolInvoke {
  name: string;
  argsJson: string;
}

export interface Cancel {
  /** optional */
  toolCallId: string;
}

export interface StreamEventsRequest {
  sessionId: string;
  afterEventId: number;
}

function createBaseSession(): Session {
  return { sessionId: "", workspaceRoot: "", toolBundlePath: "", createdAt: undefined };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.workspaceRoot !== "") {
      writer.uint32(18).string(message.workspaceRoot);
    }
    if (message.toolBundlePath !== "") {
      writer.uint32(26).string(message.toolBundlePath);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workspaceRoot = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolBundlePath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      workspaceRoot: isSet(object.workspaceRoot) ? globalThis.String(object.workspaceRoot) : "",
      toolBundlePath: isSet(object.toolBundlePath) ? globalThis.String(object.toolBundlePath) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.workspaceRoot !== "") {
      obj.workspaceRoot = message.workspaceRoot;
    }
    if (message.toolBundlePath !== "") {
      obj.toolBundlePath = message.toolBundlePath;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.sessionId = object.sessionId ?? "";
    message.workspaceRoot = object.workspaceRoot ?? "";
    message.toolBundlePath = object.toolBundlePath ?? "";
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { workspaceRoot: "", toolBundlePath: "" };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspaceRoot !== "") {
      writer.uint32(10).string(message.workspaceRoot);
    }
    if (message.toolBundlePath !== "") {
      writer.uint32(18).string(message.toolBundlePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspaceRoot = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolBundlePath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      workspaceRoot: isSet(object.workspaceRoot) ? globalThis.String(object.workspaceRoot) : "",
      toolBundlePath: isSet(object.toolBundlePath) ? globalThis.String(object.toolBundlePath) : "",
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.workspaceRoot !== "") {
      obj.workspaceRoot = message.workspaceRoot;
    }
    if (message.toolBundlePath !== "") {
      obj.toolBundlePath = message.toolBundlePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.workspaceRoot = object.workspaceRoot ?? "";
    message.toolBundlePath = object.toolBundlePath ?? "";
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { session: undefined };
}

export const CreateSessionResponse: MessageFns<CreateSessionResponse> = {
  encode(message: CreateSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return { session: isSet(object.session) ? Session.fromJSON(object.session) : undefined };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(base?: I): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(object: I): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseListSessionsRequest(): ListSessionsRequest {
  return {};
}

export const ListSessionsRequest: MessageFns<ListSessionsRequest> = {
  encode(_: ListSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListSessionsRequest {
    return {};
  },

  toJSON(_: ListSessionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(base?: I): ListSessionsRequest {
    return ListSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(_: I): ListSessionsRequest {
    const message = createBaseListSessionsRequest();
    return message;
  },
};

function createBaseListSessionsResponse(): ListSessionsResponse {
  return { sessions: [] };
}

export const ListSessionsResponse: MessageFns<ListSessionsResponse> = {
  encode(message: ListSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions) ? object.sessions.map((e: any) => Session.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => Session.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(base?: I): ListSessionsResponse {
    return ListSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(object: I): ListSessionsResponse {
    const message = createBaseListSessionsResponse();
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSessionRequest(): GetSessionRequest {
  return { sessionId: "" };
}

export const GetSessionRequest: MessageFns<GetSessionRequest> = {
  encode(message: GetSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: GetSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionRequest>, I>>(base?: I): GetSessionRequest {
    return GetSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionRequest>, I>>(object: I): GetSessionRequest {
    const message = createBaseGetSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseAgentEvent(): AgentEvent {
  return {
    eventId: 0,
    timestamp: undefined,
    sessionId: "",
    lane: 0,
    sessionStarted: undefined,
    userMessage: undefined,
    assistantMessage: undefined,
    toolCallStarted: undefined,
    toolOutputChunk: undefined,
    toolCallResult: undefined,
    fileDiff: undefined,
    status: undefined,
    error: undefined,
    toolBundleLoaded: undefined,
  };
}

export const AgentEvent: MessageFns<AgentEvent> = {
  encode(message: AgentEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== 0) {
      writer.uint32(8).int64(message.eventId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    if (message.sessionId !== "") {
      writer.uint32(26).string(message.sessionId);
    }
    if (message.lane !== 0) {
      writer.uint32(32).int32(message.lane);
    }
    if (message.sessionStarted !== undefined) {
      SessionStarted.encode(message.sessionStarted, writer.uint32(82).fork()).join();
    }
    if (message.userMessage !== undefined) {
      UserMessage.encode(message.userMessage, writer.uint32(90).fork()).join();
    }
    if (message.assistantMessage !== undefined) {
      AssistantMessage.encode(message.assistantMessage, writer.uint32(98).fork()).join();
    }
    if (message.toolCallStarted !== undefined) {
      ToolCallStarted.encode(message.toolCallStarted, writer.uint32(106).fork()).join();
    }
    if (message.toolOutputChunk !== undefined) {
      ToolOutputChunk.encode(message.toolOutputChunk, writer.uint32(114).fork()).join();
    }
    if (message.toolCallResult !== undefined) {
      ToolCallResult.encode(message.toolCallResult, writer.uint32(122).fork()).join();
    }
    if (message.fileDiff !== undefined) {
      FileDiff.encode(message.fileDiff, writer.uint32(130).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(138).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(146).fork()).join();
    }
    if (message.toolBundleLoaded !== undefined) {
      ToolBundleLoaded.encode(message.toolBundleLoaded, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eventId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lane = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sessionStarted = SessionStarted.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.userMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.assistantMessage = AssistantMessage.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.toolCallStarted = ToolCallStarted.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.toolOutputChunk = ToolOutputChunk.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.toolCallResult = ToolCallResult.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.fileDiff = FileDiff.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.toolBundleLoaded = ToolBundleLoaded.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      lane: isSet(object.lane) ? eventLaneFromJSON(object.lane) : 0,
      sessionStarted: isSet(object.sessionStarted) ? SessionStarted.fromJSON(object.sessionStarted) : undefined,
      userMessage: isSet(object.userMessage) ? UserMessage.fromJSON(object.userMessage) : undefined,
      assistantMessage: isSet(object.assistantMessage) ? AssistantMessage.fromJSON(object.assistantMessage) : undefined,
      toolCallStarted: isSet(object.toolCallStarted) ? ToolCallStarted.fromJSON(object.toolCallStarted) : undefined,
      toolOutputChunk: isSet(object.toolOutputChunk) ? ToolOutputChunk.fromJSON(object.toolOutputChunk) : undefined,
      toolCallResult: isSet(object.toolCallResult) ? ToolCallResult.fromJSON(object.toolCallResult) : undefined,
      fileDiff: isSet(object.fileDiff) ? FileDiff.fromJSON(object.fileDiff) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      toolBundleLoaded: isSet(object.toolBundleLoaded) ? ToolBundleLoaded.fromJSON(object.toolBundleLoaded) : undefined,
    };
  },

  toJSON(message: AgentEvent): unknown {
    const obj: any = {};
    if (message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.lane !== 0) {
      obj.lane = eventLaneToJSON(message.lane);
    }
    if (message.sessionStarted !== undefined) {
      obj.sessionStarted = SessionStarted.toJSON(message.sessionStarted);
    }
    if (message.userMessage !== undefined) {
      obj.userMessage = UserMessage.toJSON(message.userMessage);
    }
    if (message.assistantMessage !== undefined) {
      obj.assistantMessage = AssistantMessage.toJSON(message.assistantMessage);
    }
    if (message.toolCallStarted !== undefined) {
      obj.toolCallStarted = ToolCallStarted.toJSON(message.toolCallStarted);
    }
    if (message.toolOutputChunk !== undefined) {
      obj.toolOutputChunk = ToolOutputChunk.toJSON(message.toolOutputChunk);
    }
    if (message.toolCallResult !== undefined) {
      obj.toolCallResult = ToolCallResult.toJSON(message.toolCallResult);
    }
    if (message.fileDiff !== undefined) {
      obj.fileDiff = FileDiff.toJSON(message.fileDiff);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.toolBundleLoaded !== undefined) {
      obj.toolBundleLoaded = ToolBundleLoaded.toJSON(message.toolBundleLoaded);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentEvent>, I>>(base?: I): AgentEvent {
    return AgentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentEvent>, I>>(object: I): AgentEvent {
    const message = createBaseAgentEvent();
    message.eventId = object.eventId ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.sessionId = object.sessionId ?? "";
    message.lane = object.lane ?? 0;
    message.sessionStarted = (object.sessionStarted !== undefined && object.sessionStarted !== null)
      ? SessionStarted.fromPartial(object.sessionStarted)
      : undefined;
    message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
      ? UserMessage.fromPartial(object.userMessage)
      : undefined;
    message.assistantMessage = (object.assistantMessage !== undefined && object.assistantMessage !== null)
      ? AssistantMessage.fromPartial(object.assistantMessage)
      : undefined;
    message.toolCallStarted = (object.toolCallStarted !== undefined && object.toolCallStarted !== null)
      ? ToolCallStarted.fromPartial(object.toolCallStarted)
      : undefined;
    message.toolOutputChunk = (object.toolOutputChunk !== undefined && object.toolOutputChunk !== null)
      ? ToolOutputChunk.fromPartial(object.toolOutputChunk)
      : undefined;
    message.toolCallResult = (object.toolCallResult !== undefined && object.toolCallResult !== null)
      ? ToolCallResult.fromPartial(object.toolCallResult)
      : undefined;
    message.fileDiff = (object.fileDiff !== undefined && object.fileDiff !== null)
      ? FileDiff.fromPartial(object.fileDiff)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.toolBundleLoaded = (object.toolBundleLoaded !== undefined && object.toolBundleLoaded !== null)
      ? ToolBundleLoaded.fromPartial(object.toolBundleLoaded)
      : undefined;
    return message;
  },
};

function createBaseSessionStarted(): SessionStarted {
  return { workspaceRoot: "", toolBundlePath: "" };
}

export const SessionStarted: MessageFns<SessionStarted> = {
  encode(message: SessionStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspaceRoot !== "") {
      writer.uint32(10).string(message.workspaceRoot);
    }
    if (message.toolBundlePath !== "") {
      writer.uint32(18).string(message.toolBundlePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspaceRoot = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolBundlePath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStarted {
    return {
      workspaceRoot: isSet(object.workspaceRoot) ? globalThis.String(object.workspaceRoot) : "",
      toolBundlePath: isSet(object.toolBundlePath) ? globalThis.String(object.toolBundlePath) : "",
    };
  },

  toJSON(message: SessionStarted): unknown {
    const obj: any = {};
    if (message.workspaceRoot !== "") {
      obj.workspaceRoot = message.workspaceRoot;
    }
    if (message.toolBundlePath !== "") {
      obj.toolBundlePath = message.toolBundlePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionStarted>, I>>(base?: I): SessionStarted {
    return SessionStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionStarted>, I>>(object: I): SessionStarted {
    const message = createBaseSessionStarted();
    message.workspaceRoot = object.workspaceRoot ?? "";
    message.toolBundlePath = object.toolBundlePath ?? "";
    return message;
  },
};

function createBaseUserMessage(): UserMessage {
  return { text: "" };
}

export const UserMessage: MessageFns<UserMessage> = {
  encode(message: UserMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessage {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: UserMessage): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessage>, I>>(base?: I): UserMessage {
    return UserMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessage>, I>>(object: I): UserMessage {
    const message = createBaseUserMessage();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseAssistantMessage(): AssistantMessage {
  return { text: "", markdown: false };
}

export const AssistantMessage: MessageFns<AssistantMessage> = {
  encode(message: AssistantMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.markdown !== false) {
      writer.uint32(16).bool(message.markdown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistantMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistantMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.markdown = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistantMessage {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      markdown: isSet(object.markdown) ? globalThis.Boolean(object.markdown) : false,
    };
  },

  toJSON(message: AssistantMessage): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.markdown !== false) {
      obj.markdown = message.markdown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssistantMessage>, I>>(base?: I): AssistantMessage {
    return AssistantMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssistantMessage>, I>>(object: I): AssistantMessage {
    const message = createBaseAssistantMessage();
    message.text = object.text ?? "";
    message.markdown = object.markdown ?? false;
    return message;
  },
};

function createBaseToolCallStarted(): ToolCallStarted {
  return { toolCallId: "", name: "", argsJson: "" };
}

export const ToolCallStarted: MessageFns<ToolCallStarted> = {
  encode(message: ToolCallStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolCallId !== "") {
      writer.uint32(10).string(message.toolCallId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.argsJson !== "") {
      writer.uint32(26).string(message.argsJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.argsJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCallStarted {
    return {
      toolCallId: isSet(object.toolCallId) ? globalThis.String(object.toolCallId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      argsJson: isSet(object.argsJson) ? globalThis.String(object.argsJson) : "",
    };
  },

  toJSON(message: ToolCallStarted): unknown {
    const obj: any = {};
    if (message.toolCallId !== "") {
      obj.toolCallId = message.toolCallId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.argsJson !== "") {
      obj.argsJson = message.argsJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCallStarted>, I>>(base?: I): ToolCallStarted {
    return ToolCallStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallStarted>, I>>(object: I): ToolCallStarted {
    const message = createBaseToolCallStarted();
    message.toolCallId = object.toolCallId ?? "";
    message.name = object.name ?? "";
    message.argsJson = object.argsJson ?? "";
    return message;
  },
};

function createBaseToolOutputChunk(): ToolOutputChunk {
  return { toolCallId: "", stream: "", data: new Uint8Array(0) };
}

export const ToolOutputChunk: MessageFns<ToolOutputChunk> = {
  encode(message: ToolOutputChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolCallId !== "") {
      writer.uint32(10).string(message.toolCallId);
    }
    if (message.stream !== "") {
      writer.uint32(18).string(message.stream);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolOutputChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolOutputChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stream = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolOutputChunk {
    return {
      toolCallId: isSet(object.toolCallId) ? globalThis.String(object.toolCallId) : "",
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ToolOutputChunk): unknown {
    const obj: any = {};
    if (message.toolCallId !== "") {
      obj.toolCallId = message.toolCallId;
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolOutputChunk>, I>>(base?: I): ToolOutputChunk {
    return ToolOutputChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolOutputChunk>, I>>(object: I): ToolOutputChunk {
    const message = createBaseToolOutputChunk();
    message.toolCallId = object.toolCallId ?? "";
    message.stream = object.stream ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseToolCallResult(): ToolCallResult {
  return { toolCallId: "", exitCode: 0, errorMessage: "" };
}

export const ToolCallResult: MessageFns<ToolCallResult> = {
  encode(message: ToolCallResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolCallId !== "") {
      writer.uint32(10).string(message.toolCallId);
    }
    if (message.exitCode !== 0) {
      writer.uint32(16).int32(message.exitCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCallResult {
    return {
      toolCallId: isSet(object.toolCallId) ? globalThis.String(object.toolCallId) : "",
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: ToolCallResult): unknown {
    const obj: any = {};
    if (message.toolCallId !== "") {
      obj.toolCallId = message.toolCallId;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCallResult>, I>>(base?: I): ToolCallResult {
    return ToolCallResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallResult>, I>>(object: I): ToolCallResult {
    const message = createBaseToolCallResult();
    message.toolCallId = object.toolCallId ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseFileDiff(): FileDiff {
  return { path: "", unifiedDiff: "" };
}

export const FileDiff: MessageFns<FileDiff> = {
  encode(message: FileDiff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.unifiedDiff !== "") {
      writer.uint32(18).string(message.unifiedDiff);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileDiff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unifiedDiff = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileDiff {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      unifiedDiff: isSet(object.unifiedDiff) ? globalThis.String(object.unifiedDiff) : "",
    };
  },

  toJSON(message: FileDiff): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.unifiedDiff !== "") {
      obj.unifiedDiff = message.unifiedDiff;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileDiff>, I>>(base?: I): FileDiff {
    return FileDiff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileDiff>, I>>(object: I): FileDiff {
    const message = createBaseFileDiff();
    message.path = object.path ?? "";
    message.unifiedDiff = object.unifiedDiff ?? "";
    return message;
  },
};

function createBaseStatus(): Status {
  return { phase: "", detail: "" };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phase !== "") {
      writer.uint32(10).string(message.phase);
    }
    if (message.detail !== "") {
      writer.uint32(18).string(message.detail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.phase = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.detail = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      phase: isSet(object.phase) ? globalThis.String(object.phase) : "",
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.phase !== "") {
      obj.phase = message.phase;
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.phase = object.phase ?? "";
    message.detail = object.detail ?? "";
    return message;
  },
};

function createBaseError(): Error {
  return { message: "" };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseToolBundleLoaded(): ToolBundleLoaded {
  return { path: "", schemaVersion: "", bundleVersion: "", toolNames: [] };
}

export const ToolBundleLoaded: MessageFns<ToolBundleLoaded> = {
  encode(message: ToolBundleLoaded, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.schemaVersion !== "") {
      writer.uint32(18).string(message.schemaVersion);
    }
    if (message.bundleVersion !== "") {
      writer.uint32(26).string(message.bundleVersion);
    }
    for (const v of message.toolNames) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolBundleLoaded {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolBundleLoaded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bundleVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toolNames.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolBundleLoaded {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      schemaVersion: isSet(object.schemaVersion) ? globalThis.String(object.schemaVersion) : "",
      bundleVersion: isSet(object.bundleVersion) ? globalThis.String(object.bundleVersion) : "",
      toolNames: globalThis.Array.isArray(object?.toolNames)
        ? object.toolNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ToolBundleLoaded): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    if (message.bundleVersion !== "") {
      obj.bundleVersion = message.bundleVersion;
    }
    if (message.toolNames?.length) {
      obj.toolNames = message.toolNames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolBundleLoaded>, I>>(base?: I): ToolBundleLoaded {
    return ToolBundleLoaded.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolBundleLoaded>, I>>(object: I): ToolBundleLoaded {
    const message = createBaseToolBundleLoaded();
    message.path = object.path ?? "";
    message.schemaVersion = object.schemaVersion ?? "";
    message.bundleVersion = object.bundleVersion ?? "";
    message.toolNames = object.toolNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseClientHello(): ClientHello {
  return { sessionId: "", afterEventId: 0 };
}

export const ClientHello: MessageFns<ClientHello> = {
  encode(message: ClientHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.afterEventId !== 0) {
      writer.uint32(16).int64(message.afterEventId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.afterEventId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientHello {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      afterEventId: isSet(object.afterEventId) ? globalThis.Number(object.afterEventId) : 0,
    };
  },

  toJSON(message: ClientHello): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.afterEventId !== 0) {
      obj.afterEventId = Math.round(message.afterEventId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientHello>, I>>(base?: I): ClientHello {
    return ClientHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientHello>, I>>(object: I): ClientHello {
    const message = createBaseClientHello();
    message.sessionId = object.sessionId ?? "";
    message.afterEventId = object.afterEventId ?? 0;
    return message;
  },
};

function createBaseClientMsg(): ClientMsg {
  return { hello: undefined, userMessage: undefined, toolInvoke: undefined, cancel: undefined };
}

export const ClientMsg: MessageFns<ClientMsg> = {
  encode(message: ClientMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hello !== undefined) {
      ClientHello.encode(message.hello, writer.uint32(10).fork()).join();
    }
    if (message.userMessage !== undefined) {
      UserMessage.encode(message.userMessage, writer.uint32(18).fork()).join();
    }
    if (message.toolInvoke !== undefined) {
      ToolInvoke.encode(message.toolInvoke, writer.uint32(26).fork()).join();
    }
    if (message.cancel !== undefined) {
      Cancel.encode(message.cancel, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hello = ClientHello.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolInvoke = ToolInvoke.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cancel = Cancel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMsg {
    return {
      hello: isSet(object.hello) ? ClientHello.fromJSON(object.hello) : undefined,
      userMessage: isSet(object.userMessage) ? UserMessage.fromJSON(object.userMessage) : undefined,
      toolInvoke: isSet(object.toolInvoke) ? ToolInvoke.fromJSON(object.toolInvoke) : undefined,
      cancel: isSet(object.cancel) ? Cancel.fromJSON(object.cancel) : undefined,
    };
  },

  toJSON(message: ClientMsg): unknown {
    const obj: any = {};
    if (message.hello !== undefined) {
      obj.hello = ClientHello.toJSON(message.hello);
    }
    if (message.userMessage !== undefined) {
      obj.userMessage = UserMessage.toJSON(message.userMessage);
    }
    if (message.toolInvoke !== undefined) {
      obj.toolInvoke = ToolInvoke.toJSON(message.toolInvoke);
    }
    if (message.cancel !== undefined) {
      obj.cancel = Cancel.toJSON(message.cancel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMsg>, I>>(base?: I): ClientMsg {
    return ClientMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMsg>, I>>(object: I): ClientMsg {
    const message = createBaseClientMsg();
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? ClientHello.fromPartial(object.hello)
      : undefined;
    message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
      ? UserMessage.fromPartial(object.userMessage)
      : undefined;
    message.toolInvoke = (object.toolInvoke !== undefined && object.toolInvoke !== null)
      ? ToolInvoke.fromPartial(object.toolInvoke)
      : undefined;
    message.cancel = (object.cancel !== undefined && object.cancel !== null)
      ? Cancel.fromPartial(object.cancel)
      : undefined;
    return message;
  },
};

function createBaseToolInvoke(): ToolInvoke {
  return { name: "", argsJson: "" };
}

export const ToolInvoke: MessageFns<ToolInvoke> = {
  encode(message: ToolInvoke, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.argsJson !== "") {
      writer.uint32(18).string(message.argsJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolInvoke {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolInvoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.argsJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolInvoke {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      argsJson: isSet(object.argsJson) ? globalThis.String(object.argsJson) : "",
    };
  },

  toJSON(message: ToolInvoke): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.argsJson !== "") {
      obj.argsJson = message.argsJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolInvoke>, I>>(base?: I): ToolInvoke {
    return ToolInvoke.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolInvoke>, I>>(object: I): ToolInvoke {
    const message = createBaseToolInvoke();
    message.name = object.name ?? "";
    message.argsJson = object.argsJson ?? "";
    return message;
  },
};

function createBaseCancel(): Cancel {
  return { toolCallId: "" };
}

export const Cancel: MessageFns<Cancel> = {
  encode(message: Cancel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolCallId !== "") {
      writer.uint32(10).string(message.toolCallId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cancel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cancel {
    return { toolCallId: isSet(object.toolCallId) ? globalThis.String(object.toolCallId) : "" };
  },

  toJSON(message: Cancel): unknown {
    const obj: any = {};
    if (message.toolCallId !== "") {
      obj.toolCallId = message.toolCallId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cancel>, I>>(base?: I): Cancel {
    return Cancel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cancel>, I>>(object: I): Cancel {
    const message = createBaseCancel();
    message.toolCallId = object.toolCallId ?? "";
    return message;
  },
};

function createBaseStreamEventsRequest(): StreamEventsRequest {
  return { sessionId: "", afterEventId: 0 };
}

export const StreamEventsRequest: MessageFns<StreamEventsRequest> = {
  encode(message: StreamEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.afterEventId !== 0) {
      writer.uint32(16).int64(message.afterEventId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.afterEventId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamEventsRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      afterEventId: isSet(object.afterEventId) ? globalThis.Number(object.afterEventId) : 0,
    };
  },

  toJSON(message: StreamEventsRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.afterEventId !== 0) {
      obj.afterEventId = Math.round(message.afterEventId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamEventsRequest>, I>>(base?: I): StreamEventsRequest {
    return StreamEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamEventsRequest>, I>>(object: I): StreamEventsRequest {
    const message = createBaseStreamEventsRequest();
    message.sessionId = object.sessionId ?? "";
    message.afterEventId = object.afterEventId ?? 0;
    return message;
  },
};

export type SessionServiceService = typeof SessionServiceService;
export const SessionServiceService = {
  createSession: {
    path: "/xrunner.v1.SessionService/CreateSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSessionRequest): Buffer => Buffer.from(CreateSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSessionRequest => CreateSessionRequest.decode(value),
    responseSerialize: (value: CreateSessionResponse): Buffer =>
      Buffer.from(CreateSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateSessionResponse => CreateSessionResponse.decode(value),
  },
  listSessions: {
    path: "/xrunner.v1.SessionService/ListSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSessionsRequest): Buffer => Buffer.from(ListSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSessionsRequest => ListSessionsRequest.decode(value),
    responseSerialize: (value: ListSessionsResponse): Buffer =>
      Buffer.from(ListSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSessionsResponse => ListSessionsResponse.decode(value),
  },
  getSession: {
    path: "/xrunner.v1.SessionService/GetSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSessionRequest): Buffer => Buffer.from(GetSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSessionRequest => GetSessionRequest.decode(value),
    responseSerialize: (value: Session): Buffer => Buffer.from(Session.encode(value).finish()),
    responseDeserialize: (value: Buffer): Session => Session.decode(value),
  },
  streamEvents: {
    path: "/xrunner.v1.SessionService/StreamEvents",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: StreamEventsRequest): Buffer => Buffer.from(StreamEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StreamEventsRequest => StreamEventsRequest.decode(value),
    responseSerialize: (value: AgentEvent): Buffer => Buffer.from(AgentEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer): AgentEvent => AgentEvent.decode(value),
  },
  interact: {
    path: "/xrunner.v1.SessionService/Interact",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ClientMsg): Buffer => Buffer.from(ClientMsg.encode(value).finish()),
    requestDeserialize: (value: Buffer): ClientMsg => ClientMsg.decode(value),
    responseSerialize: (value: AgentEvent): Buffer => Buffer.from(AgentEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer): AgentEvent => AgentEvent.decode(value),
  },
  deleteSession: {
    path: "/xrunner.v1.SessionService/DeleteSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSessionRequest): Buffer => Buffer.from(GetSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSessionRequest => GetSessionRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface SessionServiceServer extends UntypedServiceImplementation {
  createSession: handleUnaryCall<CreateSessionRequest, CreateSessionResponse>;
  listSessions: handleUnaryCall<ListSessionsRequest, ListSessionsResponse>;
  getSession: handleUnaryCall<GetSessionRequest, Session>;
  streamEvents: handleServerStreamingCall<StreamEventsRequest, AgentEvent>;
  interact: handleBidiStreamingCall<ClientMsg, AgentEvent>;
  deleteSession: handleUnaryCall<GetSessionRequest, Empty>;
}

export interface SessionServiceClient extends Client {
  createSession(
    request: CreateSessionRequest,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  streamEvents(request: StreamEventsRequest, options?: Partial<CallOptions>): ClientReadableStream<AgentEvent>;
  streamEvents(
    request: StreamEventsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<AgentEvent>;
  interact(): ClientDuplexStream<ClientMsg, AgentEvent>;
  interact(options: Partial<CallOptions>): ClientDuplexStream<ClientMsg, AgentEvent>;
  interact(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<ClientMsg, AgentEvent>;
  deleteSession(
    request: GetSessionRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteSession(
    request: GetSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteSession(
    request: GetSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const SessionServiceClient = makeGenericClientConstructor(
  SessionServiceService,
  "xrunner.v1.SessionService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SessionServiceClient;
  service: typeof SessionServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
