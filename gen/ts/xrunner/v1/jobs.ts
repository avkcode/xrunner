// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.2
// source: xrunner/v1/jobs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../../google/protobuf/timestamp";
import { ArtifactRef } from "./artifacts";
import { JobRef, JobState, jobStateFromJSON, jobStateToJSON, LogChunk, ResourceHints, SandboxSpec } from "./common";
import { PolicyOverrides } from "./policies";

export const protobufPackage = "xrunner.v1";

export interface InlineWorkload {
  executable: string;
  args: string[];
  stdin: Uint8Array;
}

export interface ArtifactWorkload {
  artifact: ArtifactRef | undefined;
  entrypoint: string;
  args: string[];
}

export interface DockerRunWorkload {
  image: string;
  command: string[];
  containerEnv: { [key: string]: string };
  mounts: string[];
  workdir: string;
  network: string;
  keepContainer: boolean;
  interactive: boolean;
  tty: boolean;
  detach: boolean;
  entrypoint: string;
  extraArgs: string[];
}

export interface DockerRunWorkload_ContainerEnvEntry {
  key: string;
  value: string;
}

export interface DockerBuildWorkload {
  contextDir: string;
  dockerfile: string;
  tags: string[];
  platforms: string[];
  buildArgs: string[];
  secrets: string[];
  cacheFrom: string[];
  cacheTo: string[];
  push: boolean;
  load: boolean;
  noCache: boolean;
  quiet: boolean;
  builder: string;
  useBuildkit: boolean;
  composeFiles: string[];
  extraArgs: string[];
}

export interface Workload {
  inline?: InlineWorkload | undefined;
  artifactBased?: ArtifactWorkload | undefined;
  dockerRun?: DockerRunWorkload | undefined;
  dockerBuild?: DockerBuildWorkload | undefined;
}

export interface Job {
  ref: JobRef | undefined;
  displayName: string;
  workload: Workload | undefined;
  env: { [key: string]: string };
  state: JobState;
  createTime: Date | undefined;
  updateTime: Date | undefined;
  resource: ResourceHints | undefined;
  policy: PolicyOverrides | undefined;
  exitCode: number;
  statusMessage: string;
  sandbox: SandboxSpec | undefined;
}

export interface Job_EnvEntry {
  key: string;
  value: string;
}

export interface SubmitJobRequest {
  tenantId: string;
  displayName: string;
  workload: Workload | undefined;
  env: { [key: string]: string };
  resource: ResourceHints | undefined;
  policy: PolicyOverrides | undefined;
  sandbox: SandboxSpec | undefined;
}

export interface SubmitJobRequest_EnvEntry {
  key: string;
  value: string;
}

export interface SubmitJobResponse {
  job: Job | undefined;
}

export interface GetJobRequest {
  ref: JobRef | undefined;
}

export interface ListJobsRequest {
  tenantId: string;
}

export interface ListJobsResponse {
  jobs: Job[];
}

export interface StreamJobLogsRequest {
  ref:
    | JobRef
    | undefined;
  /** If non-zero, start streaming after this per-job log offset. */
  afterOffset: number;
}

function createBaseInlineWorkload(): InlineWorkload {
  return { executable: "", args: [], stdin: new Uint8Array(0) };
}

export const InlineWorkload: MessageFns<InlineWorkload> = {
  encode(message: InlineWorkload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executable !== "") {
      writer.uint32(10).string(message.executable);
    }
    for (const v of message.args) {
      writer.uint32(18).string(v!);
    }
    if (message.stdin.length !== 0) {
      writer.uint32(26).bytes(message.stdin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InlineWorkload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInlineWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executable = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stdin = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InlineWorkload {
    return {
      executable: isSet(object.executable) ? globalThis.String(object.executable) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      stdin: isSet(object.stdin) ? bytesFromBase64(object.stdin) : new Uint8Array(0),
    };
  },

  toJSON(message: InlineWorkload): unknown {
    const obj: any = {};
    if (message.executable !== "") {
      obj.executable = message.executable;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.stdin.length !== 0) {
      obj.stdin = base64FromBytes(message.stdin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InlineWorkload>, I>>(base?: I): InlineWorkload {
    return InlineWorkload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InlineWorkload>, I>>(object: I): InlineWorkload {
    const message = createBaseInlineWorkload();
    message.executable = object.executable ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.stdin = object.stdin ?? new Uint8Array(0);
    return message;
  },
};

function createBaseArtifactWorkload(): ArtifactWorkload {
  return { artifact: undefined, entrypoint: "", args: [] };
}

export const ArtifactWorkload: MessageFns<ArtifactWorkload> = {
  encode(message: ArtifactWorkload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifact !== undefined) {
      ArtifactRef.encode(message.artifact, writer.uint32(10).fork()).join();
    }
    if (message.entrypoint !== "") {
      writer.uint32(18).string(message.entrypoint);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArtifactWorkload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifact = ArtifactRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entrypoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactWorkload {
    return {
      artifact: isSet(object.artifact) ? ArtifactRef.fromJSON(object.artifact) : undefined,
      entrypoint: isSet(object.entrypoint) ? globalThis.String(object.entrypoint) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ArtifactWorkload): unknown {
    const obj: any = {};
    if (message.artifact !== undefined) {
      obj.artifact = ArtifactRef.toJSON(message.artifact);
    }
    if (message.entrypoint !== "") {
      obj.entrypoint = message.entrypoint;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactWorkload>, I>>(base?: I): ArtifactWorkload {
    return ArtifactWorkload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactWorkload>, I>>(object: I): ArtifactWorkload {
    const message = createBaseArtifactWorkload();
    message.artifact = (object.artifact !== undefined && object.artifact !== null)
      ? ArtifactRef.fromPartial(object.artifact)
      : undefined;
    message.entrypoint = object.entrypoint ?? "";
    message.args = object.args?.map((e) => e) || [];
    return message;
  },
};

function createBaseDockerRunWorkload(): DockerRunWorkload {
  return {
    image: "",
    command: [],
    containerEnv: {},
    mounts: [],
    workdir: "",
    network: "",
    keepContainer: false,
    interactive: false,
    tty: false,
    detach: false,
    entrypoint: "",
    extraArgs: [],
  };
}

export const DockerRunWorkload: MessageFns<DockerRunWorkload> = {
  encode(message: DockerRunWorkload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== "") {
      writer.uint32(10).string(message.image);
    }
    for (const v of message.command) {
      writer.uint32(18).string(v!);
    }
    Object.entries(message.containerEnv).forEach(([key, value]) => {
      DockerRunWorkload_ContainerEnvEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.mounts) {
      writer.uint32(34).string(v!);
    }
    if (message.workdir !== "") {
      writer.uint32(42).string(message.workdir);
    }
    if (message.network !== "") {
      writer.uint32(50).string(message.network);
    }
    if (message.keepContainer !== false) {
      writer.uint32(56).bool(message.keepContainer);
    }
    if (message.interactive !== false) {
      writer.uint32(64).bool(message.interactive);
    }
    if (message.tty !== false) {
      writer.uint32(72).bool(message.tty);
    }
    if (message.detach !== false) {
      writer.uint32(80).bool(message.detach);
    }
    if (message.entrypoint !== "") {
      writer.uint32(90).string(message.entrypoint);
    }
    for (const v of message.extraArgs) {
      writer.uint32(98).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DockerRunWorkload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDockerRunWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.command.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = DockerRunWorkload_ContainerEnvEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.containerEnv[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mounts.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workdir = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.keepContainer = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.interactive = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.tty = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.detach = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.entrypoint = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.extraArgs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DockerRunWorkload {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      command: globalThis.Array.isArray(object?.command) ? object.command.map((e: any) => globalThis.String(e)) : [],
      containerEnv: isObject(object.containerEnv)
        ? Object.entries(object.containerEnv).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      mounts: globalThis.Array.isArray(object?.mounts) ? object.mounts.map((e: any) => globalThis.String(e)) : [],
      workdir: isSet(object.workdir) ? globalThis.String(object.workdir) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      keepContainer: isSet(object.keepContainer) ? globalThis.Boolean(object.keepContainer) : false,
      interactive: isSet(object.interactive) ? globalThis.Boolean(object.interactive) : false,
      tty: isSet(object.tty) ? globalThis.Boolean(object.tty) : false,
      detach: isSet(object.detach) ? globalThis.Boolean(object.detach) : false,
      entrypoint: isSet(object.entrypoint) ? globalThis.String(object.entrypoint) : "",
      extraArgs: globalThis.Array.isArray(object?.extraArgs)
        ? object.extraArgs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DockerRunWorkload): unknown {
    const obj: any = {};
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.command?.length) {
      obj.command = message.command;
    }
    if (message.containerEnv) {
      const entries = Object.entries(message.containerEnv);
      if (entries.length > 0) {
        obj.containerEnv = {};
        entries.forEach(([k, v]) => {
          obj.containerEnv[k] = v;
        });
      }
    }
    if (message.mounts?.length) {
      obj.mounts = message.mounts;
    }
    if (message.workdir !== "") {
      obj.workdir = message.workdir;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.keepContainer !== false) {
      obj.keepContainer = message.keepContainer;
    }
    if (message.interactive !== false) {
      obj.interactive = message.interactive;
    }
    if (message.tty !== false) {
      obj.tty = message.tty;
    }
    if (message.detach !== false) {
      obj.detach = message.detach;
    }
    if (message.entrypoint !== "") {
      obj.entrypoint = message.entrypoint;
    }
    if (message.extraArgs?.length) {
      obj.extraArgs = message.extraArgs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DockerRunWorkload>, I>>(base?: I): DockerRunWorkload {
    return DockerRunWorkload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DockerRunWorkload>, I>>(object: I): DockerRunWorkload {
    const message = createBaseDockerRunWorkload();
    message.image = object.image ?? "";
    message.command = object.command?.map((e) => e) || [];
    message.containerEnv = Object.entries(object.containerEnv ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.mounts = object.mounts?.map((e) => e) || [];
    message.workdir = object.workdir ?? "";
    message.network = object.network ?? "";
    message.keepContainer = object.keepContainer ?? false;
    message.interactive = object.interactive ?? false;
    message.tty = object.tty ?? false;
    message.detach = object.detach ?? false;
    message.entrypoint = object.entrypoint ?? "";
    message.extraArgs = object.extraArgs?.map((e) => e) || [];
    return message;
  },
};

function createBaseDockerRunWorkload_ContainerEnvEntry(): DockerRunWorkload_ContainerEnvEntry {
  return { key: "", value: "" };
}

export const DockerRunWorkload_ContainerEnvEntry: MessageFns<DockerRunWorkload_ContainerEnvEntry> = {
  encode(message: DockerRunWorkload_ContainerEnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DockerRunWorkload_ContainerEnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDockerRunWorkload_ContainerEnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DockerRunWorkload_ContainerEnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DockerRunWorkload_ContainerEnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DockerRunWorkload_ContainerEnvEntry>, I>>(
    base?: I,
  ): DockerRunWorkload_ContainerEnvEntry {
    return DockerRunWorkload_ContainerEnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DockerRunWorkload_ContainerEnvEntry>, I>>(
    object: I,
  ): DockerRunWorkload_ContainerEnvEntry {
    const message = createBaseDockerRunWorkload_ContainerEnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDockerBuildWorkload(): DockerBuildWorkload {
  return {
    contextDir: "",
    dockerfile: "",
    tags: [],
    platforms: [],
    buildArgs: [],
    secrets: [],
    cacheFrom: [],
    cacheTo: [],
    push: false,
    load: false,
    noCache: false,
    quiet: false,
    builder: "",
    useBuildkit: false,
    composeFiles: [],
    extraArgs: [],
  };
}

export const DockerBuildWorkload: MessageFns<DockerBuildWorkload> = {
  encode(message: DockerBuildWorkload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contextDir !== "") {
      writer.uint32(10).string(message.contextDir);
    }
    if (message.dockerfile !== "") {
      writer.uint32(18).string(message.dockerfile);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.platforms) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.buildArgs) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.secrets) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.cacheFrom) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.cacheTo) {
      writer.uint32(66).string(v!);
    }
    if (message.push !== false) {
      writer.uint32(72).bool(message.push);
    }
    if (message.load !== false) {
      writer.uint32(80).bool(message.load);
    }
    if (message.noCache !== false) {
      writer.uint32(88).bool(message.noCache);
    }
    if (message.quiet !== false) {
      writer.uint32(96).bool(message.quiet);
    }
    if (message.builder !== "") {
      writer.uint32(106).string(message.builder);
    }
    if (message.useBuildkit !== false) {
      writer.uint32(112).bool(message.useBuildkit);
    }
    for (const v of message.composeFiles) {
      writer.uint32(122).string(v!);
    }
    for (const v of message.extraArgs) {
      writer.uint32(130).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DockerBuildWorkload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDockerBuildWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contextDir = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dockerfile = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.platforms.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.buildArgs.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.secrets.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cacheFrom.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cacheTo.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.push = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.load = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.noCache = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.quiet = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.builder = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.useBuildkit = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.composeFiles.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.extraArgs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DockerBuildWorkload {
    return {
      contextDir: isSet(object.contextDir) ? globalThis.String(object.contextDir) : "",
      dockerfile: isSet(object.dockerfile) ? globalThis.String(object.dockerfile) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      platforms: globalThis.Array.isArray(object?.platforms)
        ? object.platforms.map((e: any) => globalThis.String(e))
        : [],
      buildArgs: globalThis.Array.isArray(object?.buildArgs)
        ? object.buildArgs.map((e: any) => globalThis.String(e))
        : [],
      secrets: globalThis.Array.isArray(object?.secrets) ? object.secrets.map((e: any) => globalThis.String(e)) : [],
      cacheFrom: globalThis.Array.isArray(object?.cacheFrom)
        ? object.cacheFrom.map((e: any) => globalThis.String(e))
        : [],
      cacheTo: globalThis.Array.isArray(object?.cacheTo) ? object.cacheTo.map((e: any) => globalThis.String(e)) : [],
      push: isSet(object.push) ? globalThis.Boolean(object.push) : false,
      load: isSet(object.load) ? globalThis.Boolean(object.load) : false,
      noCache: isSet(object.noCache) ? globalThis.Boolean(object.noCache) : false,
      quiet: isSet(object.quiet) ? globalThis.Boolean(object.quiet) : false,
      builder: isSet(object.builder) ? globalThis.String(object.builder) : "",
      useBuildkit: isSet(object.useBuildkit) ? globalThis.Boolean(object.useBuildkit) : false,
      composeFiles: globalThis.Array.isArray(object?.composeFiles)
        ? object.composeFiles.map((e: any) => globalThis.String(e))
        : [],
      extraArgs: globalThis.Array.isArray(object?.extraArgs)
        ? object.extraArgs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DockerBuildWorkload): unknown {
    const obj: any = {};
    if (message.contextDir !== "") {
      obj.contextDir = message.contextDir;
    }
    if (message.dockerfile !== "") {
      obj.dockerfile = message.dockerfile;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.platforms?.length) {
      obj.platforms = message.platforms;
    }
    if (message.buildArgs?.length) {
      obj.buildArgs = message.buildArgs;
    }
    if (message.secrets?.length) {
      obj.secrets = message.secrets;
    }
    if (message.cacheFrom?.length) {
      obj.cacheFrom = message.cacheFrom;
    }
    if (message.cacheTo?.length) {
      obj.cacheTo = message.cacheTo;
    }
    if (message.push !== false) {
      obj.push = message.push;
    }
    if (message.load !== false) {
      obj.load = message.load;
    }
    if (message.noCache !== false) {
      obj.noCache = message.noCache;
    }
    if (message.quiet !== false) {
      obj.quiet = message.quiet;
    }
    if (message.builder !== "") {
      obj.builder = message.builder;
    }
    if (message.useBuildkit !== false) {
      obj.useBuildkit = message.useBuildkit;
    }
    if (message.composeFiles?.length) {
      obj.composeFiles = message.composeFiles;
    }
    if (message.extraArgs?.length) {
      obj.extraArgs = message.extraArgs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DockerBuildWorkload>, I>>(base?: I): DockerBuildWorkload {
    return DockerBuildWorkload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DockerBuildWorkload>, I>>(object: I): DockerBuildWorkload {
    const message = createBaseDockerBuildWorkload();
    message.contextDir = object.contextDir ?? "";
    message.dockerfile = object.dockerfile ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.platforms = object.platforms?.map((e) => e) || [];
    message.buildArgs = object.buildArgs?.map((e) => e) || [];
    message.secrets = object.secrets?.map((e) => e) || [];
    message.cacheFrom = object.cacheFrom?.map((e) => e) || [];
    message.cacheTo = object.cacheTo?.map((e) => e) || [];
    message.push = object.push ?? false;
    message.load = object.load ?? false;
    message.noCache = object.noCache ?? false;
    message.quiet = object.quiet ?? false;
    message.builder = object.builder ?? "";
    message.useBuildkit = object.useBuildkit ?? false;
    message.composeFiles = object.composeFiles?.map((e) => e) || [];
    message.extraArgs = object.extraArgs?.map((e) => e) || [];
    return message;
  },
};

function createBaseWorkload(): Workload {
  return { inline: undefined, artifactBased: undefined, dockerRun: undefined, dockerBuild: undefined };
}

export const Workload: MessageFns<Workload> = {
  encode(message: Workload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inline !== undefined) {
      InlineWorkload.encode(message.inline, writer.uint32(10).fork()).join();
    }
    if (message.artifactBased !== undefined) {
      ArtifactWorkload.encode(message.artifactBased, writer.uint32(18).fork()).join();
    }
    if (message.dockerRun !== undefined) {
      DockerRunWorkload.encode(message.dockerRun, writer.uint32(26).fork()).join();
    }
    if (message.dockerBuild !== undefined) {
      DockerBuildWorkload.encode(message.dockerBuild, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inline = InlineWorkload.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.artifactBased = ArtifactWorkload.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dockerRun = DockerRunWorkload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dockerBuild = DockerBuildWorkload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload {
    return {
      inline: isSet(object.inline) ? InlineWorkload.fromJSON(object.inline) : undefined,
      artifactBased: isSet(object.artifactBased) ? ArtifactWorkload.fromJSON(object.artifactBased) : undefined,
      dockerRun: isSet(object.dockerRun) ? DockerRunWorkload.fromJSON(object.dockerRun) : undefined,
      dockerBuild: isSet(object.dockerBuild) ? DockerBuildWorkload.fromJSON(object.dockerBuild) : undefined,
    };
  },

  toJSON(message: Workload): unknown {
    const obj: any = {};
    if (message.inline !== undefined) {
      obj.inline = InlineWorkload.toJSON(message.inline);
    }
    if (message.artifactBased !== undefined) {
      obj.artifactBased = ArtifactWorkload.toJSON(message.artifactBased);
    }
    if (message.dockerRun !== undefined) {
      obj.dockerRun = DockerRunWorkload.toJSON(message.dockerRun);
    }
    if (message.dockerBuild !== undefined) {
      obj.dockerBuild = DockerBuildWorkload.toJSON(message.dockerBuild);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Workload>, I>>(base?: I): Workload {
    return Workload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Workload>, I>>(object: I): Workload {
    const message = createBaseWorkload();
    message.inline = (object.inline !== undefined && object.inline !== null)
      ? InlineWorkload.fromPartial(object.inline)
      : undefined;
    message.artifactBased = (object.artifactBased !== undefined && object.artifactBased !== null)
      ? ArtifactWorkload.fromPartial(object.artifactBased)
      : undefined;
    message.dockerRun = (object.dockerRun !== undefined && object.dockerRun !== null)
      ? DockerRunWorkload.fromPartial(object.dockerRun)
      : undefined;
    message.dockerBuild = (object.dockerBuild !== undefined && object.dockerBuild !== null)
      ? DockerBuildWorkload.fromPartial(object.dockerBuild)
      : undefined;
    return message;
  },
};

function createBaseJob(): Job {
  return {
    ref: undefined,
    displayName: "",
    workload: undefined,
    env: {},
    state: 0,
    createTime: undefined,
    updateTime: undefined,
    resource: undefined,
    policy: undefined,
    exitCode: 0,
    statusMessage: "",
    sandbox: undefined,
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ref !== undefined) {
      JobRef.encode(message.ref, writer.uint32(10).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.workload !== undefined) {
      Workload.encode(message.workload, writer.uint32(26).fork()).join();
    }
    Object.entries(message.env).forEach(([key, value]) => {
      Job_EnvEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.resource !== undefined) {
      ResourceHints.encode(message.resource, writer.uint32(66).fork()).join();
    }
    if (message.policy !== undefined) {
      PolicyOverrides.encode(message.policy, writer.uint32(74).fork()).join();
    }
    if (message.exitCode !== 0) {
      writer.uint32(80).int32(message.exitCode);
    }
    if (message.statusMessage !== "") {
      writer.uint32(90).string(message.statusMessage);
    }
    if (message.sandbox !== undefined) {
      SandboxSpec.encode(message.sandbox, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = JobRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workload = Workload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Job_EnvEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.env[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resource = ResourceHints.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.policy = PolicyOverrides.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.sandbox = SandboxSpec.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job {
    return {
      ref: isSet(object.ref) ? JobRef.fromJSON(object.ref) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      workload: isSet(object.workload) ? Workload.fromJSON(object.workload) : undefined,
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      state: isSet(object.state) ? jobStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      resource: isSet(object.resource) ? ResourceHints.fromJSON(object.resource) : undefined,
      policy: isSet(object.policy) ? PolicyOverrides.fromJSON(object.policy) : undefined,
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      sandbox: isSet(object.sandbox) ? SandboxSpec.fromJSON(object.sandbox) : undefined,
    };
  },

  toJSON(message: Job): unknown {
    const obj: any = {};
    if (message.ref !== undefined) {
      obj.ref = JobRef.toJSON(message.ref);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.workload !== undefined) {
      obj.workload = Workload.toJSON(message.workload);
    }
    if (message.env) {
      const entries = Object.entries(message.env);
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.state !== 0) {
      obj.state = jobStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.resource !== undefined) {
      obj.resource = ResourceHints.toJSON(message.resource);
    }
    if (message.policy !== undefined) {
      obj.policy = PolicyOverrides.toJSON(message.policy);
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.sandbox !== undefined) {
      obj.sandbox = SandboxSpec.toJSON(message.sandbox);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Job>, I>>(base?: I): Job {
    return Job.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Job>, I>>(object: I): Job {
    const message = createBaseJob();
    message.ref = (object.ref !== undefined && object.ref !== null) ? JobRef.fromPartial(object.ref) : undefined;
    message.displayName = object.displayName ?? "";
    message.workload = (object.workload !== undefined && object.workload !== null)
      ? Workload.fromPartial(object.workload)
      : undefined;
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? ResourceHints.fromPartial(object.resource)
      : undefined;
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? PolicyOverrides.fromPartial(object.policy)
      : undefined;
    message.exitCode = object.exitCode ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.sandbox = (object.sandbox !== undefined && object.sandbox !== null)
      ? SandboxSpec.fromPartial(object.sandbox)
      : undefined;
    return message;
  },
};

function createBaseJob_EnvEntry(): Job_EnvEntry {
  return { key: "", value: "" };
}

export const Job_EnvEntry: MessageFns<Job_EnvEntry> = {
  encode(message: Job_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Job_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Job_EnvEntry>, I>>(base?: I): Job_EnvEntry {
    return Job_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Job_EnvEntry>, I>>(object: I): Job_EnvEntry {
    const message = createBaseJob_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSubmitJobRequest(): SubmitJobRequest {
  return {
    tenantId: "",
    displayName: "",
    workload: undefined,
    env: {},
    resource: undefined,
    policy: undefined,
    sandbox: undefined,
  };
}

export const SubmitJobRequest: MessageFns<SubmitJobRequest> = {
  encode(message: SubmitJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== "") {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.workload !== undefined) {
      Workload.encode(message.workload, writer.uint32(26).fork()).join();
    }
    Object.entries(message.env).forEach(([key, value]) => {
      SubmitJobRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.resource !== undefined) {
      ResourceHints.encode(message.resource, writer.uint32(42).fork()).join();
    }
    if (message.policy !== undefined) {
      PolicyOverrides.encode(message.policy, writer.uint32(50).fork()).join();
    }
    if (message.sandbox !== undefined) {
      SandboxSpec.encode(message.sandbox, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workload = Workload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = SubmitJobRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.env[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resource = ResourceHints.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.policy = PolicyOverrides.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sandbox = SandboxSpec.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitJobRequest {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      workload: isSet(object.workload) ? Workload.fromJSON(object.workload) : undefined,
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      resource: isSet(object.resource) ? ResourceHints.fromJSON(object.resource) : undefined,
      policy: isSet(object.policy) ? PolicyOverrides.fromJSON(object.policy) : undefined,
      sandbox: isSet(object.sandbox) ? SandboxSpec.fromJSON(object.sandbox) : undefined,
    };
  },

  toJSON(message: SubmitJobRequest): unknown {
    const obj: any = {};
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.workload !== undefined) {
      obj.workload = Workload.toJSON(message.workload);
    }
    if (message.env) {
      const entries = Object.entries(message.env);
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.resource !== undefined) {
      obj.resource = ResourceHints.toJSON(message.resource);
    }
    if (message.policy !== undefined) {
      obj.policy = PolicyOverrides.toJSON(message.policy);
    }
    if (message.sandbox !== undefined) {
      obj.sandbox = SandboxSpec.toJSON(message.sandbox);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitJobRequest>, I>>(base?: I): SubmitJobRequest {
    return SubmitJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitJobRequest>, I>>(object: I): SubmitJobRequest {
    const message = createBaseSubmitJobRequest();
    message.tenantId = object.tenantId ?? "";
    message.displayName = object.displayName ?? "";
    message.workload = (object.workload !== undefined && object.workload !== null)
      ? Workload.fromPartial(object.workload)
      : undefined;
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? ResourceHints.fromPartial(object.resource)
      : undefined;
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? PolicyOverrides.fromPartial(object.policy)
      : undefined;
    message.sandbox = (object.sandbox !== undefined && object.sandbox !== null)
      ? SandboxSpec.fromPartial(object.sandbox)
      : undefined;
    return message;
  },
};

function createBaseSubmitJobRequest_EnvEntry(): SubmitJobRequest_EnvEntry {
  return { key: "", value: "" };
}

export const SubmitJobRequest_EnvEntry: MessageFns<SubmitJobRequest_EnvEntry> = {
  encode(message: SubmitJobRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitJobRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitJobRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitJobRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SubmitJobRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitJobRequest_EnvEntry>, I>>(base?: I): SubmitJobRequest_EnvEntry {
    return SubmitJobRequest_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitJobRequest_EnvEntry>, I>>(object: I): SubmitJobRequest_EnvEntry {
    const message = createBaseSubmitJobRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSubmitJobResponse(): SubmitJobResponse {
  return { job: undefined };
}

export const SubmitJobResponse: MessageFns<SubmitJobResponse> = {
  encode(message: SubmitJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitJobResponse {
    return { job: isSet(object.job) ? Job.fromJSON(object.job) : undefined };
  },

  toJSON(message: SubmitJobResponse): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitJobResponse>, I>>(base?: I): SubmitJobResponse {
    return SubmitJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitJobResponse>, I>>(object: I): SubmitJobResponse {
    const message = createBaseSubmitJobResponse();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    return message;
  },
};

function createBaseGetJobRequest(): GetJobRequest {
  return { ref: undefined };
}

export const GetJobRequest: MessageFns<GetJobRequest> = {
  encode(message: GetJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ref !== undefined) {
      JobRef.encode(message.ref, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = JobRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobRequest {
    return { ref: isSet(object.ref) ? JobRef.fromJSON(object.ref) : undefined };
  },

  toJSON(message: GetJobRequest): unknown {
    const obj: any = {};
    if (message.ref !== undefined) {
      obj.ref = JobRef.toJSON(message.ref);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJobRequest>, I>>(base?: I): GetJobRequest {
    return GetJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJobRequest>, I>>(object: I): GetJobRequest {
    const message = createBaseGetJobRequest();
    message.ref = (object.ref !== undefined && object.ref !== null) ? JobRef.fromPartial(object.ref) : undefined;
    return message;
  },
};

function createBaseListJobsRequest(): ListJobsRequest {
  return { tenantId: "" };
}

export const ListJobsRequest: MessageFns<ListJobsRequest> = {
  encode(message: ListJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== "") {
      writer.uint32(10).string(message.tenantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsRequest {
    return { tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "" };
  },

  toJSON(message: ListJobsRequest): unknown {
    const obj: any = {};
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListJobsRequest>, I>>(base?: I): ListJobsRequest {
    return ListJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobsRequest>, I>>(object: I): ListJobsRequest {
    const message = createBaseListJobsRequest();
    message.tenantId = object.tenantId ?? "";
    return message;
  },
};

function createBaseListJobsResponse(): ListJobsResponse {
  return { jobs: [] };
}

export const ListJobsResponse: MessageFns<ListJobsResponse> = {
  encode(message: ListJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      Job.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(Job.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsResponse {
    return { jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => Job.fromJSON(e)) : [] };
  },

  toJSON(message: ListJobsResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => Job.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListJobsResponse>, I>>(base?: I): ListJobsResponse {
    return ListJobsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobsResponse>, I>>(object: I): ListJobsResponse {
    const message = createBaseListJobsResponse();
    message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamJobLogsRequest(): StreamJobLogsRequest {
  return { ref: undefined, afterOffset: 0 };
}

export const StreamJobLogsRequest: MessageFns<StreamJobLogsRequest> = {
  encode(message: StreamJobLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ref !== undefined) {
      JobRef.encode(message.ref, writer.uint32(10).fork()).join();
    }
    if (message.afterOffset !== 0) {
      writer.uint32(16).uint64(message.afterOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamJobLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamJobLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = JobRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.afterOffset = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamJobLogsRequest {
    return {
      ref: isSet(object.ref) ? JobRef.fromJSON(object.ref) : undefined,
      afterOffset: isSet(object.afterOffset) ? globalThis.Number(object.afterOffset) : 0,
    };
  },

  toJSON(message: StreamJobLogsRequest): unknown {
    const obj: any = {};
    if (message.ref !== undefined) {
      obj.ref = JobRef.toJSON(message.ref);
    }
    if (message.afterOffset !== 0) {
      obj.afterOffset = Math.round(message.afterOffset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamJobLogsRequest>, I>>(base?: I): StreamJobLogsRequest {
    return StreamJobLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamJobLogsRequest>, I>>(object: I): StreamJobLogsRequest {
    const message = createBaseStreamJobLogsRequest();
    message.ref = (object.ref !== undefined && object.ref !== null) ? JobRef.fromPartial(object.ref) : undefined;
    message.afterOffset = object.afterOffset ?? 0;
    return message;
  },
};

export type JobServiceService = typeof JobServiceService;
export const JobServiceService = {
  submitJob: {
    path: "/xrunner.v1.JobService/SubmitJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitJobRequest): Buffer => Buffer.from(SubmitJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubmitJobRequest => SubmitJobRequest.decode(value),
    responseSerialize: (value: SubmitJobResponse): Buffer => Buffer.from(SubmitJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubmitJobResponse => SubmitJobResponse.decode(value),
  },
  getJob: {
    path: "/xrunner.v1.JobService/GetJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetJobRequest): Buffer => Buffer.from(GetJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetJobRequest => GetJobRequest.decode(value),
    responseSerialize: (value: Job): Buffer => Buffer.from(Job.encode(value).finish()),
    responseDeserialize: (value: Buffer): Job => Job.decode(value),
  },
  listJobs: {
    path: "/xrunner.v1.JobService/ListJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListJobsRequest): Buffer => Buffer.from(ListJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListJobsRequest => ListJobsRequest.decode(value),
    responseSerialize: (value: ListJobsResponse): Buffer => Buffer.from(ListJobsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListJobsResponse => ListJobsResponse.decode(value),
  },
  streamJobLogs: {
    path: "/xrunner.v1.JobService/StreamJobLogs",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: StreamJobLogsRequest): Buffer => Buffer.from(StreamJobLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StreamJobLogsRequest => StreamJobLogsRequest.decode(value),
    responseSerialize: (value: LogChunk): Buffer => Buffer.from(LogChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer): LogChunk => LogChunk.decode(value),
  },
} as const;

export interface JobServiceServer extends UntypedServiceImplementation {
  submitJob: handleUnaryCall<SubmitJobRequest, SubmitJobResponse>;
  getJob: handleUnaryCall<GetJobRequest, Job>;
  listJobs: handleUnaryCall<ListJobsRequest, ListJobsResponse>;
  streamJobLogs: handleServerStreamingCall<StreamJobLogsRequest, LogChunk>;
}

export interface JobServiceClient extends Client {
  submitJob(
    request: SubmitJobRequest,
    callback: (error: ServiceError | null, response: SubmitJobResponse) => void,
  ): ClientUnaryCall;
  submitJob(
    request: SubmitJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitJobResponse) => void,
  ): ClientUnaryCall;
  submitJob(
    request: SubmitJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitJobResponse) => void,
  ): ClientUnaryCall;
  getJob(request: GetJobRequest, callback: (error: ServiceError | null, response: Job) => void): ClientUnaryCall;
  getJob(
    request: GetJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Job) => void,
  ): ClientUnaryCall;
  getJob(
    request: GetJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Job) => void,
  ): ClientUnaryCall;
  listJobs(
    request: ListJobsRequest,
    callback: (error: ServiceError | null, response: ListJobsResponse) => void,
  ): ClientUnaryCall;
  listJobs(
    request: ListJobsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListJobsResponse) => void,
  ): ClientUnaryCall;
  listJobs(
    request: ListJobsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListJobsResponse) => void,
  ): ClientUnaryCall;
  streamJobLogs(request: StreamJobLogsRequest, options?: Partial<CallOptions>): ClientReadableStream<LogChunk>;
  streamJobLogs(
    request: StreamJobLogsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<LogChunk>;
}

export const JobServiceClient = makeGenericClientConstructor(JobServiceService, "xrunner.v1.JobService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): JobServiceClient;
  service: typeof JobServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
