// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: xrunner/v1/remote.proto

package xrunnerv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RemoteControlService_Ping_FullMethodName    = "/xrunner.v1.RemoteControlService/Ping"
	RemoteControlService_Version_FullMethodName = "/xrunner.v1.RemoteControlService/Version"
)

// RemoteControlServiceClient is the client API for RemoteControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RemoteControlServiceClient interface {
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RemoteVersionResponse, error)
}

type remoteControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRemoteControlServiceClient(cc grpc.ClientConnInterface) RemoteControlServiceClient {
	return &remoteControlServiceClient{cc}
}

func (c *remoteControlServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RemoteControlService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteControlServiceClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RemoteVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoteVersionResponse)
	err := c.cc.Invoke(ctx, RemoteControlService_Version_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemoteControlServiceServer is the server API for RemoteControlService service.
// All implementations must embed UnimplementedRemoteControlServiceServer
// for forward compatibility.
type RemoteControlServiceServer interface {
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Version(context.Context, *emptypb.Empty) (*RemoteVersionResponse, error)
	mustEmbedUnimplementedRemoteControlServiceServer()
}

// UnimplementedRemoteControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRemoteControlServiceServer struct{}

func (UnimplementedRemoteControlServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedRemoteControlServiceServer) Version(context.Context, *emptypb.Empty) (*RemoteVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedRemoteControlServiceServer) mustEmbedUnimplementedRemoteControlServiceServer() {}
func (UnimplementedRemoteControlServiceServer) testEmbeddedByValue()                              {}

// UnsafeRemoteControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemoteControlServiceServer will
// result in compilation errors.
type UnsafeRemoteControlServiceServer interface {
	mustEmbedUnimplementedRemoteControlServiceServer()
}

func RegisterRemoteControlServiceServer(s grpc.ServiceRegistrar, srv RemoteControlServiceServer) {
	// If the following call panics, it indicates UnimplementedRemoteControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RemoteControlService_ServiceDesc, srv)
}

func _RemoteControlService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteControlServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteControlService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteControlServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteControlService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteControlServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteControlService_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteControlServiceServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// RemoteControlService_ServiceDesc is the grpc.ServiceDesc for RemoteControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RemoteControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "xrunner.v1.RemoteControlService",
	HandlerType: (*RemoteControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _RemoteControlService_Ping_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _RemoteControlService_Version_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "xrunner/v1/remote.proto",
}

const (
	RemoteFileService_ReadFile_FullMethodName        = "/xrunner.v1.RemoteFileService/ReadFile"
	RemoteFileService_WriteFileAtomic_FullMethodName = "/xrunner.v1.RemoteFileService/WriteFileAtomic"
)

// RemoteFileServiceClient is the client API for RemoteFileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RemoteFileServiceClient interface {
	ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error)
	WriteFileAtomic(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type remoteFileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRemoteFileServiceClient(cc grpc.ClientConnInterface) RemoteFileServiceClient {
	return &remoteFileServiceClient{cc}
}

func (c *remoteFileServiceClient) ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadFileResponse)
	err := c.cc.Invoke(ctx, RemoteFileService_ReadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteFileServiceClient) WriteFileAtomic(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RemoteFileService_WriteFileAtomic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemoteFileServiceServer is the server API for RemoteFileService service.
// All implementations must embed UnimplementedRemoteFileServiceServer
// for forward compatibility.
type RemoteFileServiceServer interface {
	ReadFile(context.Context, *ReadFileRequest) (*ReadFileResponse, error)
	WriteFileAtomic(context.Context, *WriteFileRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRemoteFileServiceServer()
}

// UnimplementedRemoteFileServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRemoteFileServiceServer struct{}

func (UnimplementedRemoteFileServiceServer) ReadFile(context.Context, *ReadFileRequest) (*ReadFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadFile not implemented")
}
func (UnimplementedRemoteFileServiceServer) WriteFileAtomic(context.Context, *WriteFileRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteFileAtomic not implemented")
}
func (UnimplementedRemoteFileServiceServer) mustEmbedUnimplementedRemoteFileServiceServer() {}
func (UnimplementedRemoteFileServiceServer) testEmbeddedByValue()                           {}

// UnsafeRemoteFileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemoteFileServiceServer will
// result in compilation errors.
type UnsafeRemoteFileServiceServer interface {
	mustEmbedUnimplementedRemoteFileServiceServer()
}

func RegisterRemoteFileServiceServer(s grpc.ServiceRegistrar, srv RemoteFileServiceServer) {
	// If the following call panics, it indicates UnimplementedRemoteFileServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RemoteFileService_ServiceDesc, srv)
}

func _RemoteFileService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteFileServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteFileService_ReadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteFileServiceServer).ReadFile(ctx, req.(*ReadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteFileService_WriteFileAtomic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteFileServiceServer).WriteFileAtomic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteFileService_WriteFileAtomic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteFileServiceServer).WriteFileAtomic(ctx, req.(*WriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RemoteFileService_ServiceDesc is the grpc.ServiceDesc for RemoteFileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RemoteFileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "xrunner.v1.RemoteFileService",
	HandlerType: (*RemoteFileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadFile",
			Handler:    _RemoteFileService_ReadFile_Handler,
		},
		{
			MethodName: "WriteFileAtomic",
			Handler:    _RemoteFileService_WriteFileAtomic_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "xrunner/v1/remote.proto",
}

const (
	RemotePTYService_OpenPTY_FullMethodName   = "/xrunner.v1.RemotePTYService/OpenPTY"
	RemotePTYService_StreamPTY_FullMethodName = "/xrunner.v1.RemotePTYService/StreamPTY"
	RemotePTYService_WritePTY_FullMethodName  = "/xrunner.v1.RemotePTYService/WritePTY"
	RemotePTYService_ResizePTY_FullMethodName = "/xrunner.v1.RemotePTYService/ResizePTY"
	RemotePTYService_ClosePTY_FullMethodName  = "/xrunner.v1.RemotePTYService/ClosePTY"
)

// RemotePTYServiceClient is the client API for RemotePTYService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RemotePTYServiceClient interface {
	OpenPTY(ctx context.Context, in *OpenPTYRequest, opts ...grpc.CallOption) (*OpenPTYResponse, error)
	StreamPTY(ctx context.Context, in *PTYStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PTYOutputChunk], error)
	WritePTY(ctx context.Context, in *PTYWriteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResizePTY(ctx context.Context, in *PTYResizeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ClosePTY(ctx context.Context, in *PTYCloseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type remotePTYServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRemotePTYServiceClient(cc grpc.ClientConnInterface) RemotePTYServiceClient {
	return &remotePTYServiceClient{cc}
}

func (c *remotePTYServiceClient) OpenPTY(ctx context.Context, in *OpenPTYRequest, opts ...grpc.CallOption) (*OpenPTYResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenPTYResponse)
	err := c.cc.Invoke(ctx, RemotePTYService_OpenPTY_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remotePTYServiceClient) StreamPTY(ctx context.Context, in *PTYStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PTYOutputChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RemotePTYService_ServiceDesc.Streams[0], RemotePTYService_StreamPTY_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PTYStreamRequest, PTYOutputChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RemotePTYService_StreamPTYClient = grpc.ServerStreamingClient[PTYOutputChunk]

func (c *remotePTYServiceClient) WritePTY(ctx context.Context, in *PTYWriteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RemotePTYService_WritePTY_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remotePTYServiceClient) ResizePTY(ctx context.Context, in *PTYResizeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RemotePTYService_ResizePTY_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remotePTYServiceClient) ClosePTY(ctx context.Context, in *PTYCloseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RemotePTYService_ClosePTY_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemotePTYServiceServer is the server API for RemotePTYService service.
// All implementations must embed UnimplementedRemotePTYServiceServer
// for forward compatibility.
type RemotePTYServiceServer interface {
	OpenPTY(context.Context, *OpenPTYRequest) (*OpenPTYResponse, error)
	StreamPTY(*PTYStreamRequest, grpc.ServerStreamingServer[PTYOutputChunk]) error
	WritePTY(context.Context, *PTYWriteRequest) (*emptypb.Empty, error)
	ResizePTY(context.Context, *PTYResizeRequest) (*emptypb.Empty, error)
	ClosePTY(context.Context, *PTYCloseRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRemotePTYServiceServer()
}

// UnimplementedRemotePTYServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRemotePTYServiceServer struct{}

func (UnimplementedRemotePTYServiceServer) OpenPTY(context.Context, *OpenPTYRequest) (*OpenPTYResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method OpenPTY not implemented")
}
func (UnimplementedRemotePTYServiceServer) StreamPTY(*PTYStreamRequest, grpc.ServerStreamingServer[PTYOutputChunk]) error {
	return status.Error(codes.Unimplemented, "method StreamPTY not implemented")
}
func (UnimplementedRemotePTYServiceServer) WritePTY(context.Context, *PTYWriteRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method WritePTY not implemented")
}
func (UnimplementedRemotePTYServiceServer) ResizePTY(context.Context, *PTYResizeRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ResizePTY not implemented")
}
func (UnimplementedRemotePTYServiceServer) ClosePTY(context.Context, *PTYCloseRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ClosePTY not implemented")
}
func (UnimplementedRemotePTYServiceServer) mustEmbedUnimplementedRemotePTYServiceServer() {}
func (UnimplementedRemotePTYServiceServer) testEmbeddedByValue()                          {}

// UnsafeRemotePTYServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemotePTYServiceServer will
// result in compilation errors.
type UnsafeRemotePTYServiceServer interface {
	mustEmbedUnimplementedRemotePTYServiceServer()
}

func RegisterRemotePTYServiceServer(s grpc.ServiceRegistrar, srv RemotePTYServiceServer) {
	// If the following call panics, it indicates UnimplementedRemotePTYServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RemotePTYService_ServiceDesc, srv)
}

func _RemotePTYService_OpenPTY_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenPTYRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemotePTYServiceServer).OpenPTY(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemotePTYService_OpenPTY_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemotePTYServiceServer).OpenPTY(ctx, req.(*OpenPTYRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemotePTYService_StreamPTY_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PTYStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RemotePTYServiceServer).StreamPTY(m, &grpc.GenericServerStream[PTYStreamRequest, PTYOutputChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RemotePTYService_StreamPTYServer = grpc.ServerStreamingServer[PTYOutputChunk]

func _RemotePTYService_WritePTY_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PTYWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemotePTYServiceServer).WritePTY(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemotePTYService_WritePTY_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemotePTYServiceServer).WritePTY(ctx, req.(*PTYWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemotePTYService_ResizePTY_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PTYResizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemotePTYServiceServer).ResizePTY(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemotePTYService_ResizePTY_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemotePTYServiceServer).ResizePTY(ctx, req.(*PTYResizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemotePTYService_ClosePTY_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PTYCloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemotePTYServiceServer).ClosePTY(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemotePTYService_ClosePTY_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemotePTYServiceServer).ClosePTY(ctx, req.(*PTYCloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RemotePTYService_ServiceDesc is the grpc.ServiceDesc for RemotePTYService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RemotePTYService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "xrunner.v1.RemotePTYService",
	HandlerType: (*RemotePTYServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenPTY",
			Handler:    _RemotePTYService_OpenPTY_Handler,
		},
		{
			MethodName: "WritePTY",
			Handler:    _RemotePTYService_WritePTY_Handler,
		},
		{
			MethodName: "ResizePTY",
			Handler:    _RemotePTYService_ResizePTY_Handler,
		},
		{
			MethodName: "ClosePTY",
			Handler:    _RemotePTYService_ClosePTY_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamPTY",
			Handler:       _RemotePTYService_StreamPTY_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "xrunner/v1/remote.proto",
}

const (
	RemoteShellService_EnsureShellSession_FullMethodName = "/xrunner.v1.RemoteShellService/EnsureShellSession"
	RemoteShellService_StreamShell_FullMethodName        = "/xrunner.v1.RemoteShellService/StreamShell"
	RemoteShellService_WriteShell_FullMethodName         = "/xrunner.v1.RemoteShellService/WriteShell"
	RemoteShellService_ResizeShell_FullMethodName        = "/xrunner.v1.RemoteShellService/ResizeShell"
	RemoteShellService_TailShell_FullMethodName          = "/xrunner.v1.RemoteShellService/TailShell"
	RemoteShellService_RunShell_FullMethodName           = "/xrunner.v1.RemoteShellService/RunShell"
	RemoteShellService_CloseShell_FullMethodName         = "/xrunner.v1.RemoteShellService/CloseShell"
	RemoteShellService_AttachShell_FullMethodName        = "/xrunner.v1.RemoteShellService/AttachShell"
	RemoteShellService_ListShellCommands_FullMethodName  = "/xrunner.v1.RemoteShellService/ListShellCommands"
	RemoteShellService_SearchShell_FullMethodName        = "/xrunner.v1.RemoteShellService/SearchShell"
	RemoteShellService_ListShellArtifacts_FullMethodName = "/xrunner.v1.RemoteShellService/ListShellArtifacts"
)

// RemoteShellServiceClient is the client API for RemoteShellService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RemoteShellServiceClient interface {
	EnsureShellSession(ctx context.Context, in *EnsureShellSessionRequest, opts ...grpc.CallOption) (*EnsureShellSessionResponse, error)
	StreamShell(ctx context.Context, in *ShellStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ShellOutputChunk], error)
	WriteShell(ctx context.Context, in *ShellWriteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResizeShell(ctx context.Context, in *ShellResizeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	TailShell(ctx context.Context, in *ShellTailRequest, opts ...grpc.CallOption) (*ShellTailResponse, error)
	RunShell(ctx context.Context, in *ShellRunRequest, opts ...grpc.CallOption) (*ShellRunResponse, error)
	CloseShell(ctx context.Context, in *ShellCloseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AttachShell(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ShellClientMsg, ShellServerMsg], error)
	ListShellCommands(ctx context.Context, in *ListShellCommandsRequest, opts ...grpc.CallOption) (*ListShellCommandsResponse, error)
	SearchShell(ctx context.Context, in *ShellSearchRequest, opts ...grpc.CallOption) (*ShellSearchResponse, error)
	ListShellArtifacts(ctx context.Context, in *ListShellArtifactsRequest, opts ...grpc.CallOption) (*ListShellArtifactsResponse, error)
}

type remoteShellServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRemoteShellServiceClient(cc grpc.ClientConnInterface) RemoteShellServiceClient {
	return &remoteShellServiceClient{cc}
}

func (c *remoteShellServiceClient) EnsureShellSession(ctx context.Context, in *EnsureShellSessionRequest, opts ...grpc.CallOption) (*EnsureShellSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnsureShellSessionResponse)
	err := c.cc.Invoke(ctx, RemoteShellService_EnsureShellSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteShellServiceClient) StreamShell(ctx context.Context, in *ShellStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ShellOutputChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RemoteShellService_ServiceDesc.Streams[0], RemoteShellService_StreamShell_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ShellStreamRequest, ShellOutputChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RemoteShellService_StreamShellClient = grpc.ServerStreamingClient[ShellOutputChunk]

func (c *remoteShellServiceClient) WriteShell(ctx context.Context, in *ShellWriteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RemoteShellService_WriteShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteShellServiceClient) ResizeShell(ctx context.Context, in *ShellResizeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RemoteShellService_ResizeShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteShellServiceClient) TailShell(ctx context.Context, in *ShellTailRequest, opts ...grpc.CallOption) (*ShellTailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShellTailResponse)
	err := c.cc.Invoke(ctx, RemoteShellService_TailShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteShellServiceClient) RunShell(ctx context.Context, in *ShellRunRequest, opts ...grpc.CallOption) (*ShellRunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShellRunResponse)
	err := c.cc.Invoke(ctx, RemoteShellService_RunShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteShellServiceClient) CloseShell(ctx context.Context, in *ShellCloseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RemoteShellService_CloseShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteShellServiceClient) AttachShell(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ShellClientMsg, ShellServerMsg], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RemoteShellService_ServiceDesc.Streams[1], RemoteShellService_AttachShell_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ShellClientMsg, ShellServerMsg]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RemoteShellService_AttachShellClient = grpc.BidiStreamingClient[ShellClientMsg, ShellServerMsg]

func (c *remoteShellServiceClient) ListShellCommands(ctx context.Context, in *ListShellCommandsRequest, opts ...grpc.CallOption) (*ListShellCommandsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListShellCommandsResponse)
	err := c.cc.Invoke(ctx, RemoteShellService_ListShellCommands_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteShellServiceClient) SearchShell(ctx context.Context, in *ShellSearchRequest, opts ...grpc.CallOption) (*ShellSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShellSearchResponse)
	err := c.cc.Invoke(ctx, RemoteShellService_SearchShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remoteShellServiceClient) ListShellArtifacts(ctx context.Context, in *ListShellArtifactsRequest, opts ...grpc.CallOption) (*ListShellArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListShellArtifactsResponse)
	err := c.cc.Invoke(ctx, RemoteShellService_ListShellArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemoteShellServiceServer is the server API for RemoteShellService service.
// All implementations must embed UnimplementedRemoteShellServiceServer
// for forward compatibility.
type RemoteShellServiceServer interface {
	EnsureShellSession(context.Context, *EnsureShellSessionRequest) (*EnsureShellSessionResponse, error)
	StreamShell(*ShellStreamRequest, grpc.ServerStreamingServer[ShellOutputChunk]) error
	WriteShell(context.Context, *ShellWriteRequest) (*emptypb.Empty, error)
	ResizeShell(context.Context, *ShellResizeRequest) (*emptypb.Empty, error)
	TailShell(context.Context, *ShellTailRequest) (*ShellTailResponse, error)
	RunShell(context.Context, *ShellRunRequest) (*ShellRunResponse, error)
	CloseShell(context.Context, *ShellCloseRequest) (*emptypb.Empty, error)
	AttachShell(grpc.BidiStreamingServer[ShellClientMsg, ShellServerMsg]) error
	ListShellCommands(context.Context, *ListShellCommandsRequest) (*ListShellCommandsResponse, error)
	SearchShell(context.Context, *ShellSearchRequest) (*ShellSearchResponse, error)
	ListShellArtifacts(context.Context, *ListShellArtifactsRequest) (*ListShellArtifactsResponse, error)
	mustEmbedUnimplementedRemoteShellServiceServer()
}

// UnimplementedRemoteShellServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRemoteShellServiceServer struct{}

func (UnimplementedRemoteShellServiceServer) EnsureShellSession(context.Context, *EnsureShellSessionRequest) (*EnsureShellSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnsureShellSession not implemented")
}
func (UnimplementedRemoteShellServiceServer) StreamShell(*ShellStreamRequest, grpc.ServerStreamingServer[ShellOutputChunk]) error {
	return status.Error(codes.Unimplemented, "method StreamShell not implemented")
}
func (UnimplementedRemoteShellServiceServer) WriteShell(context.Context, *ShellWriteRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteShell not implemented")
}
func (UnimplementedRemoteShellServiceServer) ResizeShell(context.Context, *ShellResizeRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ResizeShell not implemented")
}
func (UnimplementedRemoteShellServiceServer) TailShell(context.Context, *ShellTailRequest) (*ShellTailResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TailShell not implemented")
}
func (UnimplementedRemoteShellServiceServer) RunShell(context.Context, *ShellRunRequest) (*ShellRunResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunShell not implemented")
}
func (UnimplementedRemoteShellServiceServer) CloseShell(context.Context, *ShellCloseRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseShell not implemented")
}
func (UnimplementedRemoteShellServiceServer) AttachShell(grpc.BidiStreamingServer[ShellClientMsg, ShellServerMsg]) error {
	return status.Error(codes.Unimplemented, "method AttachShell not implemented")
}
func (UnimplementedRemoteShellServiceServer) ListShellCommands(context.Context, *ListShellCommandsRequest) (*ListShellCommandsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListShellCommands not implemented")
}
func (UnimplementedRemoteShellServiceServer) SearchShell(context.Context, *ShellSearchRequest) (*ShellSearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchShell not implemented")
}
func (UnimplementedRemoteShellServiceServer) ListShellArtifacts(context.Context, *ListShellArtifactsRequest) (*ListShellArtifactsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListShellArtifacts not implemented")
}
func (UnimplementedRemoteShellServiceServer) mustEmbedUnimplementedRemoteShellServiceServer() {}
func (UnimplementedRemoteShellServiceServer) testEmbeddedByValue()                            {}

// UnsafeRemoteShellServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemoteShellServiceServer will
// result in compilation errors.
type UnsafeRemoteShellServiceServer interface {
	mustEmbedUnimplementedRemoteShellServiceServer()
}

func RegisterRemoteShellServiceServer(s grpc.ServiceRegistrar, srv RemoteShellServiceServer) {
	// If the following call panics, it indicates UnimplementedRemoteShellServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RemoteShellService_ServiceDesc, srv)
}

func _RemoteShellService_EnsureShellSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureShellSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).EnsureShellSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_EnsureShellSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).EnsureShellSession(ctx, req.(*EnsureShellSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteShellService_StreamShell_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ShellStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RemoteShellServiceServer).StreamShell(m, &grpc.GenericServerStream[ShellStreamRequest, ShellOutputChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RemoteShellService_StreamShellServer = grpc.ServerStreamingServer[ShellOutputChunk]

func _RemoteShellService_WriteShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShellWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).WriteShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_WriteShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).WriteShell(ctx, req.(*ShellWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteShellService_ResizeShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShellResizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).ResizeShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_ResizeShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).ResizeShell(ctx, req.(*ShellResizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteShellService_TailShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShellTailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).TailShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_TailShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).TailShell(ctx, req.(*ShellTailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteShellService_RunShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShellRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).RunShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_RunShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).RunShell(ctx, req.(*ShellRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteShellService_CloseShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShellCloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).CloseShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_CloseShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).CloseShell(ctx, req.(*ShellCloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteShellService_AttachShell_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RemoteShellServiceServer).AttachShell(&grpc.GenericServerStream[ShellClientMsg, ShellServerMsg]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RemoteShellService_AttachShellServer = grpc.BidiStreamingServer[ShellClientMsg, ShellServerMsg]

func _RemoteShellService_ListShellCommands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListShellCommandsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).ListShellCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_ListShellCommands_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).ListShellCommands(ctx, req.(*ListShellCommandsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteShellService_SearchShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShellSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).SearchShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_SearchShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).SearchShell(ctx, req.(*ShellSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoteShellService_ListShellArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListShellArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteShellServiceServer).ListShellArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoteShellService_ListShellArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteShellServiceServer).ListShellArtifacts(ctx, req.(*ListShellArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RemoteShellService_ServiceDesc is the grpc.ServiceDesc for RemoteShellService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RemoteShellService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "xrunner.v1.RemoteShellService",
	HandlerType: (*RemoteShellServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnsureShellSession",
			Handler:    _RemoteShellService_EnsureShellSession_Handler,
		},
		{
			MethodName: "WriteShell",
			Handler:    _RemoteShellService_WriteShell_Handler,
		},
		{
			MethodName: "ResizeShell",
			Handler:    _RemoteShellService_ResizeShell_Handler,
		},
		{
			MethodName: "TailShell",
			Handler:    _RemoteShellService_TailShell_Handler,
		},
		{
			MethodName: "RunShell",
			Handler:    _RemoteShellService_RunShell_Handler,
		},
		{
			MethodName: "CloseShell",
			Handler:    _RemoteShellService_CloseShell_Handler,
		},
		{
			MethodName: "ListShellCommands",
			Handler:    _RemoteShellService_ListShellCommands_Handler,
		},
		{
			MethodName: "SearchShell",
			Handler:    _RemoteShellService_SearchShell_Handler,
		},
		{
			MethodName: "ListShellArtifacts",
			Handler:    _RemoteShellService_ListShellArtifacts_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamShell",
			Handler:       _RemoteShellService_StreamShell_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AttachShell",
			Handler:       _RemoteShellService_AttachShell_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "xrunner/v1/remote.proto",
}
